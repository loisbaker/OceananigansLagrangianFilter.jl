# Technical comments

- The online and offline filtering both work on GPU, just make sure CUDA is installed in the environment and loaded, and set `architecture = GPU()`
- The post-processing interpolation step using [`regrid_to_mean_position!`](@ref "regrid_to_mean_position!") isn't currently set up to work in domains with immersed boundaries or with more than one bounded dimension. Interpolation results might be junk near the boundary!
- For the offline filter, saved fields to be filtered need to be on `Center` grid. For fields that aren't already on a `Center` grid, you can interpolate them before output as below. Velocities should be on their standard grid.
```julia
Tc = Field(@at (Center, Center, Center) T) 
```
- As with any moving average, there are endpoint effects. For the offline filter, a time window at each end of the filtered timeseries of the order of the inverse of the cutoff frequency should be excluded from any further analysis. For the online filter, this is only necessary at the beginning of the timeseries. 
- This method is not tested with open boundaries. There is a fundamental causal issue with knowing the Lagrangian mean near a boundary when part of the trajectory on which it relies is outside of the domain. There are ways to approximate the solution near the open boundary to allow the code to run, (e.g. setting an open boundary condition on the Lagrangian filtered variables) but then the near-boundary region should be discarded. 
- This package can be used to filter output from other numerical models (offline). In particular, model output that shares the same Arakawa type-C grid (such as MITgcm) can easily be manipulated into Oceananigans output format and run through the Lagrangian filter. 
- Eulerian filtering can be performed in two ways. The first (naive) way is to set `compute_Eulerian_filter = true` in the configuration for the offline filter, or use `compute_Eulerian_filter!` in the online filter. This will use the filter output file (and therefore data output at your filter output frequency rather than the original data frequency) to loop over that data and compute the Eulerian mean at each timestep. For small datasets with high output frequency (see examples) this is suitable. The second way is only possible for the offline filter, and is analogous to how the Lagrangian filter is computed. This is better for large datasets. Run the offline filter as you would for the Lagrangian filter, but set `advection = nothing` in the `OfflineFilterConfig`, and the Eulerian mean will be computed instead. Note that the maps are now meaningless, so `map_to_mean` should be `false` and no regridding performed at the end. 