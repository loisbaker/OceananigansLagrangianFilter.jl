<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Background: PDEs for Lagrangian filtering · OceananigansLagrangianFilter.jl</title><meta name="title" content="Background: PDEs for Lagrangian filtering · OceananigansLagrangianFilter.jl"/><meta property="og:title" content="Background: PDEs for Lagrangian filtering · OceananigansLagrangianFilter.jl"/><meta property="twitter:title" content="Background: PDEs for Lagrangian filtering · OceananigansLagrangianFilter.jl"/><meta name="description" content="Documentation for OceananigansLagrangianFilter.jl."/><meta property="og:description" content="Documentation for OceananigansLagrangianFilter.jl."/><meta property="twitter:description" content="Documentation for OceananigansLagrangianFilter.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OceananigansLagrangianFilter.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../quick_start/">Quick start</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Eulerian_Lagrangian_definitions/">Eulerian and Lagrangian averaging</a></li><li class="is-active"><a class="tocitem" href>Background: PDEs for Lagrangian filtering</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#ODEs-for-Eulerian-time-averages"><span>ODEs for Eulerian time averages</span></a></li><li><a class="tocitem" href="#Online-exponential-Lagrangian-filtering"><span>Online exponential Lagrangian filtering</span></a></li><li><a class="tocitem" href="#Offline-exponential-Lagrangian-filtering"><span>Offline exponential Lagrangian filtering</span></a></li></ul></li><li><a class="tocitem" href="../online_equations/">Online Lagrangian filtering equations</a></li><li><a class="tocitem" href="../offline_equations/">Offline Lagrangian filtering equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Online filtering</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../online_filtering/online_implementation/">Online filtering implementation</a></li><li><a class="tocitem" href="../../online_filtering/choosing_online_filters/">Choosing online filters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Offline filtering</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../offline_filtering/offline_implementation/">Offline filtering implementation</a></li><li><a class="tocitem" href="../../offline_filtering/choosing_offline_filters/">Choosing offline filters</a></li><li><a class="tocitem" href="../../offline_filtering/offline_how_it_works/">How it works</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../literated/online_filter_geostrophic_adjustment/">Geostrophic adjustment online</a></li><li><a class="tocitem" href="../../literated/offline_filter_geostrophic_adjustment/">Geostrophic adjustment offline</a></li><li><a class="tocitem" href="../../literated/offline_filter_shallow_water_IO/">Shallow water inertial oscillation offline</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theory</a></li><li class="is-active"><a href>Background: PDEs for Lagrangian filtering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Background: PDEs for Lagrangian filtering</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://loisbaker.github.io/OceananigansLagrangianFilter.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Background:-PDEs-for-Lagrangian-filtering"><a class="docs-heading-anchor" href="#Background:-PDEs-for-Lagrangian-filtering">Background: PDEs for Lagrangian filtering</a><a id="Background:-PDEs-for-Lagrangian-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Background:-PDEs-for-Lagrangian-filtering" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Lagrangian averaging (or, equivalently, Lagrangian <em>filtering</em>) is an effective way to decompose complex multi-scale flows into wave and mean components, as it allows separation based on <em>intrinsic</em> frequency of processes, that is, frequency in the frame of the flow. </p><p>Lagrangian means are usually found by seeding virtual particles in numerical simulations and keeping track of their positions. However, various methods for calculating Lagrangian means through the solution of PDEs have recently been developed (<a href="../../references/#kafiabadComputingLagrangianMeans2023">Kafiabad and Vanneste, 2023</a>; <a href="../../references/#bakerLagrangianFilteringWave2025">Baker <em>et al.</em>, 2025</a>; <a href="../../references/#minzEfficientLagrangianAveraging2025">Minz <em>et al.</em>, 2025</a>), removing the need for particle tracking. These PDE-based methods are flexible, and allow various ways of computing the Lagrangian mean dependent on the use case. Some considerations include:</p><ol><li>Should the filtering be performed <em>online</em> (at simulation time) or <em>offline</em> (after simulation time, using saved data)?</li><li>How important is the filter shape - can we get away with a less strict low-pass?</li><li>How often do we need to find the Lagrangian mean? Once per averaging interval, or at every time? </li></ol><p>These considerations will determine how the Lagrangian average should be performed, and how OceananigansLagrangianFilter is used. </p><p>Before describing how to find Lagrangian averages with PDEs, we first describe the simpler case of finding Eulerian averages with ODEs. </p><h2 id="ODEs-for-Eulerian-time-averages"><a class="docs-heading-anchor" href="#ODEs-for-Eulerian-time-averages">ODEs for Eulerian time averages</a><a id="ODEs-for-Eulerian-time-averages-1"></a><a class="docs-heading-anchor-permalink" href="#ODEs-for-Eulerian-time-averages" title="Permalink"></a></h2><p>We consider some scalar function <span>$f(t)$</span> (for now neglecting the spatial dimension), from which we would like to obtain <span>$\bar{f}$</span>, its low-pass filter. We know <span>$f$</span> only at the current simulation time <span>$t$</span>, and it can only depend on past times by causality, so we must have </p><p class="math-container">\[\begin{equation}
    \bar{f}(t) = \int_{-\infty}^t K(t,s) f(s)\,\mathrm{d} s\,,
\end{equation}\]</p><p>for some weight function <span>$K(t,s)$</span>, whose shape (a function of <span>$s$</span>) could depend on the current time <span>$t$</span>. </p><p>We look for an evolution equation of <span>$\bar{f}$</span> and take the time derivative, finding:</p><p class="math-container">\[\begin{equation}\label{time_evol1}
    \dot{\bar{f}}(t) = K(t,t) f(t) + \int_{-\infty}^t \frac{\partial}{\partial t}K(t,s) \,\mathrm{d} s\,.
\end{equation}\]</p><p>To be able to close this equation so that it only depends on information available at the current time, we need either:</p><ol><li><span>$\frac{\partial}{\partial t}K(t,s) = \alpha(t)K(t,s)$</span>, so that the integral in \eqref{time_evol1} can be expressed in terms of <span>$\bar{f}$</span>.</li><li><span>$\frac{\partial}{\partial t}K(t,s) = 0$</span>, so that <span>$K(t,s) \equiv G(s)$</span>, and the weight function <span>$G(s)$</span> does not change as <span>$t$</span> increases. </li></ol><p>These two options give rise to different schemes. </p><h3 id="Temporal-averaging-with-moving-exponential-weight-functions"><a class="docs-heading-anchor" href="#Temporal-averaging-with-moving-exponential-weight-functions">Temporal averaging with moving exponential weight functions</a><a id="Temporal-averaging-with-moving-exponential-weight-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-averaging-with-moving-exponential-weight-functions" title="Permalink"></a></h3><p>In this case, the most general weight function satisfies <span>$\frac{\partial}{\partial t}K(t,s) = \alpha(t)K(t,s)$</span>. However, we additionally constrain the weight function by imposing that although the reference time of the weight function changes with the simulation time  <span>$t$</span>, it&#39;s shape should not, so <span>$K(t,s) = G(t-s)$</span>, and <span>$\bar{f}$</span> is a convolution between the impulse response <span>$G(t)$</span> and <span>$f$</span>. This then implies that </p><p class="math-container">\[\begin{equation}
    K(t,s) \equiv G(t -s) = \alpha e^{-\alpha (t -s)}
\end{equation}\]</p><p>for some constant <span>$\alpha$</span>. With this special exponential weight function, the normalisation </p><p class="math-container">\[\begin{equation}
    \int_{-\infty}^t G(t - s) \, ds = 1
\end{equation}\]</p><p>holds at all times so <span>$\bar{f}$</span> describes the exponential mean at all times (after some initial spin-up), and is given by</p><p class="math-container">\[\begin{equation}\label{exponentialODE}
    \dot{\bar{f}}(t) = \alpha(f(t) - \bar{f}(t))\,.
\end{equation}\]</p><p>Therefore, when the weight function <span>$G(t)$</span> is exponential (or composed of a small number of exponentials, as will be descibed later) equation \eqref{exponentialODE} can be solved alongside the governing equation for <span>$f(t)$</span> and the exponential mean found &#39;on-the-fly&#39;. The methods that are currently implemented in OceananigansLagrangianFilter are based on sums of exponential weight functions.</p><h3 id="Temporal-averaging-with-fixed-arbitrary-weight-functions"><a class="docs-heading-anchor" href="#Temporal-averaging-with-fixed-arbitrary-weight-functions">Temporal averaging with fixed arbitrary weight functions</a><a id="Temporal-averaging-with-fixed-arbitrary-weight-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-averaging-with-fixed-arbitrary-weight-functions" title="Permalink"></a></h3><p>In this case, the weight function <span>$G(s)$</span> doesn&#39;t shift with the simulation time <span>$t$</span>, so the low pass variable</p><p class="math-container">\[\begin{equation}
    \bar{f}(t) = \int_{-\infty}^t G(s) f(s)\,\mathrm{d} s
\end{equation}\]</p><p>only truly describes the low-pass filtered field as <span>$t \rightarrow \infty$</span>. The weight function <span>$G(s)$</span> can take any form, but should satisfy the normalisation </p><p class="math-container">\[\begin{equation}
    \int_{-\infty}^\infty G(s) \,\mathrm{d} s = 1\,.
\end{equation}\]</p><p>In reality, we consider some finite interval <span>$[t^* - T/2, t^* + T/2]$</span> for some reference time <span>$t^*$</span>, and consider</p><p class="math-container">\[\begin{equation}
    \bar{f}(t,t^*) = \int_{t^* - T/2}^t G(t^* - s) f(s)\,\mathrm{d} s\,,
\end{equation}\]</p><p>where <span>$\bar{f}(t^* + T/2,t^*)$</span> is our desired output, <span>$G(t)$</span> is only non-zero on <span>$[-T/2,T/2]$</span>, and <span>$\bar{f}$</span> satisfies</p><p class="math-container">\[\begin{equation}
    \dot{\bar{f}}(t,t^*) = G(t^* - t)f(t)\,.
\end{equation}\]</p><p>We can think of <span>$t^*_i = T/2 + iT$</span>, where <span>$T$</span> is the averaging interval, and <span>$i \in \{0,1,2,....\}$</span> as defining a coarse time, and solve for the mean at each <span>$t^*_i$</span> by reinitialising <span>$\bar{f}$</span> after each time <span>$T$</span> so that <span>$\bar{f}(iT,t^*_i) = 0$</span>.</p><p>Methods for filtering with arbitrary weight functions in this way are described in <a href="../../references/#bakerLagrangianFilteringWave2025">Baker <em>et al.</em> (2025)</a>. These are not yet implemented in OceananigansLagrangianFilter, but raise an issue on our <a href="https://github.com/loisbaker/OceananigansLagrangianFilter.jl">github</a> if you&#39;re interested in using these methods. </p><h2 id="Online-exponential-Lagrangian-filtering"><a class="docs-heading-anchor" href="#Online-exponential-Lagrangian-filtering">Online exponential Lagrangian filtering</a><a id="Online-exponential-Lagrangian-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Online-exponential-Lagrangian-filtering" title="Permalink"></a></h2><p>Here, we demonstrate the how the (single) exponential Lagrangian mean can be found online. This is the basic idea behind OceananigansLagrangianFilter, and is a simplified version of the exponential Lagrangian averaging described in (<a href="../../references/#minzEfficientLagrangianAveraging2025">Minz <em>et al.</em>, 2025</a>). We define (see <a href="../Eulerian_Lagrangian_definitions/#Lagrangian-averaging">Lagrangian averaging</a> for general definitions):</p><p class="math-container">\[\begin{equation}\label{singleexpfstar}
    f^*(\vb*{\varphi}(\vb*{a},t),t) = \int_{-\infty}^t \alpha e^{-\alpha(t-s)}f(\vb*{\varphi}(\vb*{a},s),s)\,\mathrm{d} s\,,
\end{equation}\]</p><p>for some inverse timescale <span>$\alpha$</span>. Taking the time derivative of \eqref{singleexpfstar} at fixed <span>$\vb*{a}$</span>, and using the chain rule, gives</p><p class="math-container">\[\begin{equation}
    \frac{\partial f^*}{\partial t}(\vb*{\varphi}(\vb*{a},t),t) + \frac{\partial \vb*{\varphi}}{\partial t}(\vb*{a},t)\cdot \nabla f^*(\vb*{\varphi}(\vb*{a},t),t) = \alpha(f(\vb*{\varphi}(\vb*{a},t),t) - f^*(\vb*{\varphi}(\vb*{a},t),t))\,.
\end{equation}\]</p><p>Setting <span>$\vb*{\varphi}(\vb*{a},t) = \vb*{x}$</span>, and noting that <span>$\frac{\partial \vb*{\varphi}}{\partial t} (\vb*{a},t)= \vb*{u}(\vb*{\varphi}(\vb*{a},t),t)$</span> by definition of the flow map, we have</p><p class="math-container">\[\begin{equation}\label{fstareqnsingleexp}
    \frac{\partial f^*}{\partial t}(\vb*{x},t) + \vb*{u} \cdot\nabla f^*(\vb*{x},t) = \alpha(f(\vb*{x},t) - f^*(\vb*{x},t))\,.
\end{equation}\]</p><p>This equation can then be solved alongside the dynamical equations of the simulation (which will determine <span>$f$</span> and <span>$\vb*{u}$</span>) to find <span>$f^*$</span> at all times (after some suitable spin-up period). </p><p>If we also want to find the generalised Lagrangian mean <span>$\bar{f}^{\mathrm{L}}$</span> (see definition in <a href="../Eulerian_Lagrangian_definitions/#Lagrangian-averaging">Lagrangian averaging</a>), we define a map</p><p class="math-container">\[\begin{equation}\label{Xidefonline}
\vb*{\Xi}(\vb*{\varphi}(\vb*{a},t),t) = \int_{-\infty}^t \alpha e^{-\alpha(t-s)}\vb*{\varphi}(\vb*{a},s)\,\mathrm{d} s\,.
\end{equation}\]</p><p>Taking the time derivative, we find (c.f. \eqref{fstareqnsingleexp})</p><p class="math-container">\[\begin{equation}\label{Xieqnsingleexp}
    \frac{\partial \vb*{\Xi}}{\partial t}(\vb*{x},t) + \vb*{u} \cdot\nabla \vb*{\Xi}(\vb*{x},t) = \alpha(\vb*{x} - \vb*{\Xi}(\vb*{x},t))\,.
\end{equation}\]</p><p>Defining a perturbation <span>$\vb*{\xi}(\vb*{x},t) = \vb*{\Xi}(\vb*{x},t) - \vb*{x}$</span>, we then have</p><p class="math-container">\[\begin{equation}\label{xieqnsingleexp}
    \frac{\partial \vb*{\xi}}{\partial t}(\vb*{x},t) + \vb*{u} \cdot\nabla \vb*{\xi}(\vb*{x},t) = - \vb*{u} - \alpha \vb*{\Xi}(\vb*{x},t)\,.
\end{equation}\]</p><p>After having solved \eqref{fstareqnsingleexp} for <span>$f^*$</span> and \eqref{xieqnsingleexp} for <span>$\vb*{\xi}$</span>, the relation</p><p class="math-container">\[\begin{equation}
\bar{f}^{\mathrm{L}}(\vb*{\Xi}(\vb*{x},t),t) = f^*(\vb*{x},t)
\end{equation}\]</p><p>can be used to recover <span>$\bar{f}^{\mathrm{L}}$</span> by interpolation.</p><h2 id="Offline-exponential-Lagrangian-filtering"><a class="docs-heading-anchor" href="#Offline-exponential-Lagrangian-filtering">Offline exponential Lagrangian filtering</a><a id="Offline-exponential-Lagrangian-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Offline-exponential-Lagrangian-filtering" title="Permalink"></a></h2><p>While the exponential formulation is efficient as it finds the mean at all times, it limits the possible weight functions, and in particular limits us to causal averages, which depend at any time only on past data. For this reason, we also develop an approach to exponential filtering that combines a &#39;forward&#39; exponential average (as in \eqref{fstareqnsingleexp}) with a &#39;backward&#39; exponential pass. </p><p>For \eqref{fstareqnsingleexp} to be run `backwards&#39;, the filtering must be performed offline and the data therefore saved at wave-resolving resolution. The forward and backward outputs are summed to give a total output with a more desirable effective filter shape, at the expense of the necessity of saving data. </p><p>The goal is to find </p><p class="math-container">\[\begin{equation}
    f^*(\vb*{\varphi}(\vb*{a},t), t) = \int_{-\infty}^{\infty} G(t-s) f(\vb*{\varphi}(\vb*{a},s), s) \, \mathrm{d} s\,,
\end{equation}\]</p><p>where <span>$G(t)$</span> is even such that <span>$G(t) \equiv G(|t|)$</span>. </p><p>This property means that the weight function will be centred on the reference time <span>$t$</span>, and the frequency response of this filter will be real. Such filters have <em>linear phase shift</em> (or, in this case, <em>zero phase shift</em>,* since <span>$G$</span> is symmetric about <span>$t=0$</span>). This means that the phases of frequencies in the pass-band are not modified, in contrast to filters like the single sided exponential used in <a href="../online_equations/#Online-Lagrangian-filtering-equations">Online Lagrangian filtering</a>. See <a href="../../online_filtering/choosing_online_filters/#Choosing-online-filters">Choosing online filters</a> for more explanation of weight functions.</p><p>For a single exponential (as opposed to sums of exponentials, to be introduced in <a href="../online_equations/#Online-Lagrangian-filtering-equations">Online Lagrangian filtering equations</a> and <a href="../offline_equations/#Offline-Lagrangian-filtering-equations">Offline Lagrangian filtering equations</a>),</p><p class="math-container">\[\begin{equation}
G(t-s) = \frac{\alpha}{2} e^{-\alpha|t-s|}\,,
\end{equation}\]</p><p>i.e. a `double sided exponential&#39;.</p><p>On the forward pass (which can be performed either &#39;online&#39; at the same time as the simulation, or `offline&#39; on saved data - our implementation does this offline since data must be saved for the backward pass anyway) we calculate</p><p class="math-container">\[\begin{equation}
    f^*_1(\vb*{\varphi}(\vb*{a},t), t) = \int_{-\infty}^{t} G(t-s) f(\vb*{\varphi}(\vb*{a},s), s) \, \mathrm{d} s\,,
\end{equation}\]</p><p>and on the backward pass (which must be performed offline) we calculate </p><p class="math-container">\[\begin{equation}\label{f2star}
    f^*_2(\vb*{\varphi}(\vb*{a},t), t) = \int_{t}^{\infty} G(t-s) f(\vb*{\varphi}(\vb*{a},s), s) \, \mathrm{d} s\,,
\end{equation}\]</p><p>such that <span>$f^* = f^*_1 + f^*_2$</span>.</p><p>The forward equation is identical to the online scheme \eqref{fstareqnsingleexp}, aside from a factor of two to ensure that the normalisation of the weight function still holds:</p><p class="math-container">\[\begin{equation}\label{f1stareqnsingleexp}
    \frac{\partial f^*_1}{\partial t}(\vb*{x},t) + \vb*{u} \cdot\nabla f^*_1(\vb*{x},t) = \frac{\alpha}{2}(f(\vb*{x},t) - f^*_1(\vb*{x},t))\,.
\end{equation}\]</p><p>The backward equation is found by first taking the time derivative of \eqref{f2star} to give</p><p class="math-container">\[\begin{equation}\label{f2stareqnsingleexp}
    \frac{\partial f^*_2}{\partial t}(\vb*{x},t) + \vb*{u} \cdot\nabla f^*_2(\vb*{x},t) = -\frac{\alpha}{2}(f(\vb*{x},t) - f^*(\vb*{x},t))\,,
\end{equation}\]</p><p>then setting <span>$\tilde{t} = T - t$</span>, where <span>$T$</span> is the total simulation time (or end of the desired averaging interval), to give</p><p class="math-container">\[\begin{equation}\label{f2stareqnsingleexp_timereversed}
    \frac{\partial f^*_2}{\partial \tilde{t}}(\vb*{x},T - \tilde{t}) - \vb*{u} \cdot\nabla f^*_2(\vb*{x},T - \tilde{t}) = \frac{\alpha}{2}(f(\vb*{x},T - \tilde{t}) - f^*(\vb*{x},T - \tilde{t}))\,.
\end{equation}\]</p><p>Defining <span>$\tilde{f}^*_2(\vb*{x},\tilde{t}) = f^*_2(\vb*{x},T-\tilde{t})$</span>, <span>$\tilde{f}(\vb*{x},\tilde{t}) = f(\vb*{x},T-\tilde{t})$</span>, and <span>$\tilde{\vb*{u}}(\vb*{x},\tilde{t}) = \vb*{u}(\vb*{x},T-\tilde{t})$</span>, we then have</p><p class="math-container">\[\begin{equation}\label{f2stareqnsingleexp_tilde}
    \frac{\partial \tilde{f}^*_2}{\partial \tilde{t}}(\vb*{x},\tilde{t}) + \tilde{\vb*{u}} \cdot\nabla \tilde{f}^*_2(\vb*{x},\tilde{t}) = \frac{\alpha}{2}(f(\vb*{x},\tilde{t}) - \tilde{f}^*(\vb*{x},\tilde{t}))\,,
\end{equation}\]</p><p>which is equivalent to \eqref{f1stareqnsingleexp} solved backwards with negated velocities. Equations for the forward and backward maps <span>$\vb*{\Xi}_1$</span> and <span>$\vb*{\Xi}_2$</span> (c.f. \eqref{Xidefonline}) can be found similarly by setting <span>$f$</span> to the identity in \eqref{fstareqnsingleexp} and \eqref{f2stareqnsingleexp_tilde}.</p><p>Having found <span>$f_1^*$</span> on the forward pass, and <span>$\tilde{f}_2^*$</span> on the backward pass, we then calculate </p><p class="math-container">\[\begin{equation}
f^*(\vb*{x},t) = f_1^*(\vb*{x},t) + \tilde{f}_2^*(\vb*{x},T-t)\,.
\end{equation}\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Eulerian_Lagrangian_definitions/">« Eulerian and Lagrangian averaging</a><a class="docs-footer-nextpage" href="../online_equations/">Online Lagrangian filtering equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 30 October 2025 12:56">Thursday 30 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
