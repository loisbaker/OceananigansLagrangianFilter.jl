var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"Baker,Â L.Â E.; Kafiabad,Â H.Â A.; Maitland-Davies,Â C. and Vanneste,Â J. (2025). Lagrangian Filtering for Waveâ€“Mean Flow Decomposition. JournalÂ ofÂ FluidÂ Mechanics 1009, A40.\n\n\n\nKafiabad,Â H.Â A. and Vanneste,Â J. (2023). Computing Lagrangian Means. JournalÂ ofÂ FluidÂ Mechanics 960, A36.\n\n\n\nMinz,Â A.; Baker,Â L.Â E.; Kafiabad,Â H.Â A. and Vanneste,Â J. (2025). Efficient Lagrangian Averaging with Exponential Filters. Phys.Â Rev.Â Fluids 10, 074902.\n\n\n\nWagner,Â G.Â L.; Silvestri,Â S.; Constantinou,Â N.Â C.; Ramadhan,Â A.; Campin,Â J.-M.; Hill,Â C.; Chor,Â T.; Strong-Wright,Â J.; Lee,Â X.Â K.; Poulin,Â F.; Souza,Â A.; Burns,Â K.Â J.; Marshall,Â J. and Ferrari,Â R. (2025). High-level, high-resolution ocean modeling at all scales with Oceananigans, arXivÂ preprint, arXiv:2502.14148.\n\n\n\n","category":"section"},{"location":"offline_filtering/offline_implementation/#Offline-filtering-implementation","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"The offline Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved after the original Oceananigans simulation (or, feasibly, using any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the tracer(s) f to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. \n\nThe offline filter uses mostly the same functions as the online filter to define filtered fields and their forcings, but in this case most of the process is 'under the hood', as the user only needs to provide the simulation data and specify the configuration. An example is given in offline_filter_geostrophic_adjustment.jl, and more detail is given in how it works.\n\nA short example of how to implement offline filtering on a GPU is given below:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`","category":"section"},{"location":"contributing/#Contributing-to-OceananigansLagrangianFilter","page":"Contributing","title":"Contributing to OceananigansLagrangianFilter","text":"We welcome contributions! These include issue reports, bug fixes, and feature implementations. Contributions are reviewed on Github via pull request; to get started, fork the repository, make changes, and issue a pull request. You can also contribute by submitting an issue.","category":"section"},{"location":"contributing/#Issue-reports","page":"Contributing","title":"Issue reports","text":"If you find a bug or unexpected behaviour, please create an issue on github. Please provide as much detail as possible, including the version of OceananigansLagrangianFilter and Oceananigans, your platform and architecture (CPU/GPU), and a minimal working example that demonstrates your problem as simply as possible. ","category":"section"},{"location":"contributing/#Proposing-features","page":"Contributing","title":"Proposing features","text":"You can propose new features by creating an issue on github.","category":"section"},{"location":"contributing/#Contributing-code","page":"Contributing","title":"Contributing code","text":"Code contributions, from fixing typos to implementing new features, are very welcome! If you'd like to contribute, just fork the repository, make changes, and issue a pull request. If you'd like to discuss a potential modification or use-case first, feel free to get in touch at lois.baker [at] ed.ac.uk.","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"ðŸ› ï¸ Installation","text":"To install OceananigansLagrangianFilter, run the following in the Julia REPL:\n\nusing Pkg\nPkg.add(\"OceananigansLagrangianFilter\")\n\nOr, in Pkg mode (by pressing ]):\n\npkg> add OceananigansLagrangianFilter\n\nTo install the dev version:\n\nusing Pkg\nPkg.add(url = \"https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git\")\n\nOr, in Pkg mode (by pressing ]):\n\nadd https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git","category":"section"},{"location":"online_filtering/choosing_online_filters/#Choosing-online-filters","page":"Choosing online filters","title":"Choosing online filters","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#General-form","page":"Choosing online filters","title":"General form","text":"The offline filter uses weight functions of the form\n\nG(t) = \nbegincases\nsum_n=1^N2 e^-c_n t(a_ncosd_n t + b_nsind_n t) hspace1cm t  0  \n 0 t leq 0 \nendcases\n\nwhere a_n, b_n, c_n, and d_n are real scalars, c_n  0, and N should be even. N is the number of exponentials that are summed to form the weight function, and should be even as the exponentials come in complex conjugate pairs to keep calculations real. These coefficients can be provided to OnlineFilterConfig inside the NamedTuple filter_params.\n\nfilter_params = (a1 = 1, b1 = 1, c1 = 1, d1 = 1)\n\nFor the weight function to be normalised (so that the mean of a constant is the constant itself), these coefficients must be chosen such that\n\nsum_n=1^N2 fraca_nc_n + b_n d_nc_n^2 +d_n^2 = 1\n\nUn-normalised filters can be used, but map_to_mean will be set to false as the maps no longer make sense. \n\nFor N2 sets of coefficients, the weight function is composed of N exponentials, and N filtered tracers are needed to find the Lagrangian mean of each tracer. The number of equations that the filtering simulation solves is therefore linear in N, so beware making N too large. ","category":"section"},{"location":"online_filtering/choosing_online_filters/#Exponential","page":"Choosing online filters","title":"Exponential","text":"For the special case of one (real) exponential, N can be set to 1 (this is the only exception toN being even). The parameters a_1 and c_1 can then be provided:\n\nfilter_params = (a1 = 1, c1 = 1)\n\ngiving \n\nG(t) = a_1 e^-c_1 t","category":"section"},{"location":"online_filtering/choosing_online_filters/#Butterworth","page":"Choosing online filters","title":"Butterworth","text":"Instead of providing the individual parameters in filter_params, the user can provide N (the filter order, which should be even or 1) and freq_c (the cut-off frequency) to use a filter with frequency response \n\nbeginequation\n    hatG(omega) = frac1sqrt1 + left(omegaomega_cright)^2N\nendequation \n\nThis is a Butterworth order-N filter.","category":"section"},{"location":"online_filtering/online_implementation/#Online-filtering-implementation","page":"Online filtering implementation","title":"Online filtering implementation","text":"The online Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved at the same time as the governing equations of your simulation, in which the original tracer f is being found. Filtered velocities can also be found. This means that equations for the filtered tracers, and optionally the maps (see Online Lagrangian filtering equations) need to be passed to your model. \n\nOceananigansLagrangianFilter provides helper functions to define these extra fields and their forcings, and an example is given at Geostrophic adjustment online.\n\nOther helper functions are provided to initialise the filtered variables, define output fields that compute f^*, regrid f^* to barf^mathrmL (see Lagrangian averaging), compute the Eulerian filter for comparison, compute a shifted time variable, and output a final NetCDF file. \n\nWe summarise here the protocol for implementing online Lagrangian filtering\n\nInstall OceananigansLagrangianFilter in your environment (see Quick Start).\nLoad OceananigansLagrangianFilter and its utility functions at the top of your script. This automatically loads Oceananigans.\n\nusing OceananigansLagrangianFilter\nusing OceananigansLagrangianFilter.Utils\n\nSetup your parameters, grid, tracers, and forcing as normal\nDefine your filter_config - an OnlineFilterConfig. This takes as arguments:\ngrid: the grid you have already defined\noutput_filename: a filename to save filtered output to\nvar_names_to_filter: a tuple of strings defining the names of variables to filter. These can be any of your tracers. Velocities to filter don't need to be listed here (see below).\nvelocity_names: the velocity names that you want to use to compute Lagrangian trajectories. These are also the velocities that will be filtered if compute_mean_velocities = true.\nN and freq_c: Can be provided together to give a Butterworth filter of order N with cutoff frequency freq_c. \nfilter_params: a named tuple of coefficients a1, b1, c1, d1, a2, b2, c2, d2, etc defining a filter kernel (see Choosing online filters).\nmap_to_mean: A Bool determining whether to compute the maps vb*xi_Ck and vb*xi_Sk and solve their equations (see Online Lagrangian filtering equations).\ncompute_mean_velocities: A Bool determining whether to compute and output the mean velocities. They are computed from the maps vb*xi_Ck and vb*xi_Sk, so if map_to_mean=false and compute_mean_velocities=true the maps will still be computed. \n\nfilter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = filename_stem * \".jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = f/2)\n\nCreate the filtered variables g_Ck, g_Sk, vb*xi_Ck and vb*xi_Sk using the function create_filtered_vars, which only needs the filter_config. These filtered variables will be added to the model as tracers.\n\nfiltered_vars = create_filtered_vars(filter_config)\n\nCreate forcing for these filtered variables using the function create_forcing. This implements the right-hand-sides of the tracer and map equations (see Online Lagrangian filtering equations). Merge this filter_forcing with your existing forcing. \n\nfilter_forcing = create_forcing(filtered_vars, filter_config)\nforcing = merge(forcing, filter_forcing);\n\nIf you're using a closure, you'll need to tell the filtered scalars not to use a closure (although they could be given a closure if necessary for stability - this has proved unecessary so far and is more accurate). A helper function zero_closure_for_filtered_vars to set the diffusivity to zero for each of the filtered variables is provided.\n\nzero_filtered_var_closure = zero_closure_for_filtered_vars(filter_config)\n\nDefine the closure for your model variables using the zero_filtered_var_closure\n\nhorizontal_closure = HorizontalScalarDiffusivity(Î½=1e-6, Îº=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nvertical_closure = VerticalScalarDiffusivity(Î½=1e-6 , Îº=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nclosure = (horizontal_closure, vertical_closure)\n\nDefine the model with the combined (original and filtered) tracers, forcing and closure. This should work with both NonHydrostaticModel and HydrostaticFreeSurfaceModel.\nInitialise your model variables as normal\nInitialise the filtered variables (this uses the previously initialised model variables to give a better initialisation, so needs to be performed after the previous step)\n\ninitialise_filtered_vars_from_model(model, filter_config)\n\nDefine the simulation, any callbacks, conjure_time_step_wizard, etc as normal\nUse the create_output_fields helper function to define the output fields (this defines the outputs f^* and vb*Xi so that all of the intermediate filter variables are not output by default, though they could be examined as for any other tracer)\n\noutputs = create_output_fields(model, filter_config)\n\nAdd in any other output fields, including the original fields if desired (not included by default in the online filter).\n\noutputs[\"b\"] = model.tracers.b\noutputs[\"T\"] = model.tracers.T\noutputs[\"u\"] = model.velocities.u\noutputs[\"v\"] = model.velocities.v\noutputs[\"w\"] = model.velocities.w\n\nDefine a JLD2Writer for the outputs. The filename should be the same as filter_config.output_filename. For the post-processing functions provided in the next few steps, this does need to be a JLD2Writer rather than a NetCDFWriter, but a helper function is provided to output a final .nc file if needed. \nRun the simulation\n\nrun!(simulation)\n\nOptionally regrid to mean position using regrid_to_mean_position!. This adds a new field to the output data file.\n\nif filter_config.map_to_mean\n    regrid_to_mean_position!(filter_config)\nend\n\nOptionally compute the Eulerian filter (with the same filter_params) using compute_Eulerian_filter!.\n\ncompute_Eulerian_filter!(filter_config)\n\nOptionally compute a shifted time coordinate to give a more appropriate reference time for the average. The new reference time is calculated as the weighted mean of time: t_shift = int_-infty^t G(t-s)s mathrmd s\n\ncompute_time_shift!(filter_config)\n\nOptionally output a final NetCDF file using jld2_to_netcdf. This helper function should work for any .jld2 Oceananigans output. \n\njld2_to_netcdf(filename_stem * \".jld2\", filename_stem * \".nc\")","category":"section"},{"location":"library/#OceananigansLagrangianFilter.jl-Library","page":"Library","title":"OceananigansLagrangianFilter.jl Library","text":"Documenting the public user interface.","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.Utils","page":"Library","title":"OceananigansLagrangianFilter.Utils","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(;\n\n)\n\nA configuration object for online filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(; grid::AbstractGrid,\n                        output_filename::String = \"online_filtered_output\",\n                        var_names_to_filter::Tuple{Vararg{String}},\n                        velocity_names::Tuple{Vararg{String}},\n                        N::Union{Int, Nothing} = nothing,\n                        freq_c::Union{Int, Nothing} = nothing,\n                        filter_params::Union{NamedTuple, Nothing} = nothing,\n                        map_to_mean::Bool = true,\n                        compute_mean_velocities::Bool = true,\n                        npad::Int = 5,\n                        filter_mode::String = \"online\",\n                        label::String = \"\"\n                        )\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\ngrid: (required) The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\noutput_filename: The filename for the output of the online filtered data. Default: \"online_filtered_output\".\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nN, freq_c: Parameters for a Butterworth filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"online\". TODO use multiple dispatch for this instead.\nlabel: A String label for the variables that will be created to pass to the model. For use when multiple filter configurations are to be run  at the same time.  Default: \"\".\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\n\nNx = 50\nNz = 20\nL = 10kilometers \nH = 100meters \n\ngrid = RectilinearGrid(CPU(),size = (Nx, Nz), \n                       x = (-L/2, L/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))\n\nfilter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = \"test_filter.jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = 1e-4/2)\n\n# output\nâ”Œ Info: Advection for Lagrangian filtering will be performed using full model velocities u, v, and w. \nâ””         Maps for regridding to mean position will be computed corresponding to velocities: (\"u\", \"w\").\n[ Info: Mean velocities corresponding to (\"u\", \"w\") will be computed.\n[ Info: Variables to be filtered: (\"b\", \"T\"). Ensure these are valid tracer or auxiliary field names in the simulation.\n[ Info: Setting filter parameters to use Butterworth order 2, cutoff frequency 5.0e-5\nOnlineFilterConfig(50Ã—1Ã—20 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=200.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=5.0, \"test_filter.jld2\", (\"b\", \"T\"), (\"u\", \"w\"), (a1 = 1.421067568548072e-20, b1 = -7.071067811865475e-5, c1 = 3.535533905932738e-5, d1 = -3.535533905932738e-5, N_coeffs = 1), true, true, 5, \"online\", \"\")\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(;\n    \n)\n\nA configuration object for apply_offline_filter.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(; original_data_filename::String,\n                    var_names_to_filter::Tuple{Vararg{String}},\n                    velocity_names::Tuple{Vararg{String}},\n                    T_start::Union{Real,Nothing} = nothing,\n                    T_end::Union{Real,Nothing} = nothing,\n                    T::Union{Real,Nothing} = nothing,\n                    architecture::AbstractArchitecture = CPU(),\n                    T_out::Union{Real,Nothing} = nothing,\n                    N::Union{Int, Nothing} = nothing,\n                    freq_c::Union{Int, Nothing} = nothing,\n                    filter_params::Union{NamedTuple, Nothing} = nothing,\n                    Î”t::Union{Real,Nothing} = nothing,\n                    backend::AbstractInMemoryBackend = InMemory(4),\n                    map_to_mean::Bool = true,\n                    forward_output_filename::String = \"forward_output.jld2\",\n                    backward_output_filename::String = \"backward_output.jld2\",\n                    output_filename::String = \"filtered_output.jld2\",\n                    npad::Int = 5,\n                    compute_mean_velocities::Bool = true,\n                    delete_intermediate_files::Bool = true,\n                    compute_Eulerian_filter::Bool = false,\n                    output_netcdf::Bool = false,\n                    output_original_data::Bool = true,\n                    advection::Union{AbstractAdvectionScheme, Nothing} = WENO(),\n                    grid::Union{AbstractGrid, Nothing} = nothing,\n                    filter_mode::String = \"offline\",\n                    label::String = \"\")\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\noriginal_data_filename: (required) The path to the JLD2 file containing the original Oceananigans output data.\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nT_start: Start time for the filter. Must be within the time range of the data. If not given, defaults to either T_end - T (if they are given), or the start time of the original data.\nT_end: End time for the filter. Must be within the time range of the data. If not given, defaults to either Tstart + T (after Tstart given or computed, if T is given), or the end time of the original data.\nT: Duration of the filtering. If not given, defaults to Tend - Tstart (after Tstart and Tend are given or computed).\narchitecture: The architecture (CPU or GPU) to be used for the filtering computation. Default: CPU().\nT_out: The output time step for the filtered data. If nothing, it defaults to the time step of the original data.\nN, freq_c: Parameters for a Butterworth squared filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nÎ”t: The time step for the internal Lagrangian filter simulation. If nothing, it defaults to T_out / 10, but this may not be appropriate.\nbackend: The backend for loading FieldTimeSeries data. See Oceananigans.Fields.FieldTimeSeries. Default: InMemory(4).\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\nforward_output_filename: The filename for the output of the forward filter pass. Default: \"forward_output.jld2\".\nbackward_output_filename: The filename for the output of the backward filter pass. Default: \"backward_output.jld2\".\noutput_filename: The filename for the final combined and mapped output. Default: \"filtered_output.jld2\".\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\ndelete_intermediate_files: A Bool indicating whether to delete forward_output.jld2 and backward_output.jld2 after the final combined file is created. Default: true.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\noutput_netcdf: A Bool indicating whether to also convert the final JLD2 output file to a NetCDF file. Default: false.\noutput_original_data: A Bool indicating whether to include the original data in the final output file for comparison. Default: true.\nadvection: The advection scheme to use for the Lagrangian filter simulation. Default: WENO(). Using lower-order schemes may be a source of error.\ngrid: The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"offline\". TODO use multiple dispatch for this instead.\nlabel: A String label for the variables that will be created to pass to the model. For use when multiple filter configurations are to be run  at the same time.  Default: \"\".\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\npath_to_sim = \"../test/data/reference_sim.jld2\"\nfilter_config = OfflineFilterConfig(original_data_filename=path_to_sim, \n                                    output_filename = \"output_file.jld2\", \n                                    var_names_to_filter = (\"b\",), \n                                    velocity_names = (\"u\",\"w\"), \n                                    architecture = CPU(), \n                                    Î”t = 20minutes, \n                                    T_out = 1hour, \n                                    N = 2, \n                                    freq_c = 1e-4/2, \n                                    compute_mean_velocities = true, \n                                    output_netcdf = true, \n                                    delete_intermediate_files = true, \n                                    compute_Eulerian_filter = true) \n\n# output\nâ”Œ Info: Advection for Lagrangian filtering will be performed using only velocities (\"u\", \"w\") - \nâ”‚ any other velocity components will be zero by default. Maps for regridding to mean position will\nâ”” be computed corresponding to velocities: (\"u\", \"w\").\n[ Info: Mean velocities corresponding to (\"u\", \"w\") will be computed.\n[ Info: Filter interval will be from T_start=0.0 to T_end=86400.0, duration T=86400.0\n[ Info: Setting filter parameters to use Butterworth squared, order 2, cutoff frequency 5.0e-5\nOfflineFilterConfig(\"../test/data/reference_sim.jld2\", (\"b\",), (\"u\", \"w\"), 0.0, 86400.0, 86400.0, CPU(), 3600.0, (a1 = 1.767766952966369e-5, b1 = 1.767766952966369e-5, c1 = 3.535533905932738e-5, d1 = 3.535533905932738e-5, N_coeffs = 1), 1200.0, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"output_file.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ”‚   â””â”€â”€ buffer_scheme: Centered(order=2)\nâ””â”€â”€ advecting_velocity_scheme: Centered(order=4), 10Ã—1Ã—10 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=1000.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=10.0, \"offline\", \"\")\n\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter-Tuple{Any}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter","text":"run_offline_Lagrangian_filter(config::OfflineFilterConfig)\n\nRuns an offline Lagrangian filter on an Oceananigans FieldTimeSeries dataset as configured by config.\n\nThis function performs a series of steps to filter the data:\n\nPrepare data on disk: The input data is copied and manipulated on disk to be suitable for the forward and backward Lagrangian simulations.\nRun forward simulation: A LagrangianFilter model is created and run forward in time to compute the first half of the filter contributions.\nRun backward simulation: The input data is re-prepared for a backward pass, and the simulation is run a second time to compute the remaining contributions.\nCombine results: The forward and backward simulation outputs are summed to produce the final filtered data.\nPost-processing: Optional post-processing steps are performed, including regridding the data to the mean position, computing a comparative Eulerian filter, and converting the output file to NetCDF.\nCleanup: Intermediate files are removed to save disk space.\n\nArguments\n\nconfig: An instance of OfflineFilterConfig that specifies all parameters and file paths for the filtering process.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!","text":"compute_Eulerian_filter!(config::AbstractConfig)\n\nComputes the Eulerian filter for specified variables and writes the results to a combined output file. This function performs a direct, convolution-style filtering of a time series by applying a weighting function to the data at each time step.\n\nThe function iterates through each variable to be filtered:\n\nReads data: The entire time series of the variable is read from the  JLD2 file.\nApplies weighting: At each output time, a weighting function G is  computed and applied to the entire time series. The weighted data is summed  to produce the filtered field.\nWrites output: The resulting filtered field is saved back to the  same JLD2 file in a new group with the _Eulerian_filtered suffix.\n\nThis method serves as a benchmark for comparison with the main Lagrangian filter.\n\nThe method uses data saved to the filter output file - incase we decide to save this at lower frequency than the original data, it should be rewritten to use the original data file instead.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, and filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_time_shift!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_time_shift!","text":"compute_time_shift!(config::AbstractConfig)\n\nComputes the time shift for an online filter based on its coefficients and writes the shifted time series to the output file.\n\nThis function is only applicable for online filtering. The time shift is computed as the time delay introduced by the filter's transfer function. This new time series is stored in a new group called timeseries/t_shifted within the output JLD2 file.\n\nArguments\n\nconfig: A configuration object of type OfflineFilterConfig which contains the filter_mode, output_filename, and filter_params (filter coefficients).\n\nThrows\n\nerror: If config.filter_mode is not \"online\". The time shift for offline (forward-backward) filtering is zero by definition due to an even weight function.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_filtered_vars","text":"create_filtered_vars(config::AbstractConfig)\n\nCreates a Tuple of Symbols representing the names of the filtered tracer variables.\n\nFor a single-exponential filter (N_coeffs = 0.5), the function generates names with a _C1 suffix.\nFor a multi-coefficient filter (N_coeffs > 0.5), it generates pairs of names for each coefficient, suffixed with _C# and _S#, where # is the coefficient index.\n\nIf map_to_mean or compute_mean_velocities is enabled in the configuration, additional symbols are created for the spatial mapping variables corresponding to each velocity component, prefixed with xi_ and suffixed with the corresponding coefficient names.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables to filter, the filter parameters, and the map_to_mean and compute_mean_velocities booleans.\n\nReturns\n\nA Tuple of Symbols representing the names of the filtered variables to be used as tracers in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_forcing-Tuple{Tuple{Vararg{Symbol}}, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_forcing","text":"create_forcing(filtered_vars::Tuple{Vararg{Symbol}}, config::AbstractConfig)\n\nCreates a NamedTuple of forcing functions for each filtered variable and, if enabled, for the spatial mapping variables. These forcing terms are used to numerically integrate the filter equations.\n\nThe function handles two cases: a single-exponential filter (N_coeffs = 0.5) and a multi-coefficient Butterworth squared filter (N_coeffs > 0.5).\n\nFor standard filtered variables, the forcing is a combination of terms derived from the filter's coefficients and a term from the original data.\nFor spatial mapping variables (if map_to_mean or compute_mean_velocities is true), the forcing includes terms derived from the filter's coefficients and a term from the original velocity data.\n\nArguments\n\nfiltered_vars: A Tuple of Symbols representing the names of the filtered variables.\nconfig: An instance of AbstractConfig containing the names of the variables to be filtered, velocity names, and the filter parameters.\n\nReturns\n\nA NamedTuple where each key is a variable name from filtered_vars and each value is a Tuple of the corresponding forcing functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_input_data_on_disk-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_input_data_on_disk","text":"create_input_data_on_disk(config::AbstractConfig; direction::String=\"forward\")\n\nPrepares a new JLD2 file on disk with the time-filtered data for a forward or backward Lagrangian simulation.\n\nThis function performs the following steps:\n\nValidates direction: Ensures the direction is either \"forward\"  or \"backward\".\nCreates a new file: A new JLD2 file is created with the suffix  _filter_input.jld2 and any existing file with the same name is deleted.\nCopies metadata: Key metadata from the original file (e.g., grid  information) is copied to the new file to maintain consistency.\nTime truncation: The data is truncated to the time range specified by  config.T_start and config.T_end.\nTime shifting:\nFor \"forward\" filtering, a new time variable is created, shifted so   that t=0 corresponds to config.T_start.\nFor \"backward\" filtering, the data is re-ordered and a new time   variable is created, shifted so that t=0 corresponds to config.T_end.\nVelocity reversal: For \"backward\" filtering, the velocity fields  (u, v, w) are negated to correctly simulate backward advection.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and time specifications.\n\nKeyword Arguments\n\ndirection: A String indicating the simulation direction. It must be either \"forward\" (the default) or \"backward\".\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_original_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_original_vars","text":"create_original_vars(config::AbstractConfig)\n\nCreates a NamedTuple to serve as auxiliary fields for the original variables  in a simulation. The fields are initialised from the input data to ensure that they are in the correct location. - the value of the data is unimportant.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables and the simulation grid.\n\nReturns\n\nA NamedTuple where each key is a Symbol of a variable name to be filtered, and each value is an empty CenterField for that variable.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_output_fields-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_output_fields","text":"create_output_fields(model::AbstractModel, config::AbstractConfig)\n\nReconstructs the final output fields from the model's tracers and auxiliary fields. This function performs the following steps:\n\nReconstructs filtered variables: For each variable to be filtered, it sums  the contributions from the individual filter coefficients (_C and _S  tracers) using the coefficients from filter_params.\nReconstructs spatial mapping fields: If spatial mapping is enabled,  the function also reconstructs the xi_ fields that represent the filtered  position.\nBuilds mean velocities: If compute_mean_velocities is true, the function  reconstructs the mean velocity fields using the xi_ fields.\nIncludes original data: The original data is added to the output  dictionary for comparison and analysis if config.output_original_data  is true.\n\nArguments\n\nmodel: An instance of an AbstractModel containing the tracer and auxiliary fields.\nconfig: An instance of AbstractConfig with the names of the variables, velocity components, and filter parameters.\n\nReturns\n\nA Dict where keys are the names of the output fields (e.g., var_name_Lagrangian_filtered, xi_vel_name, var_name) and values are the corresponding reconstructed Fields.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_frequency_response-Tuple{AbstractArray, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_frequency_response","text":"get_frequency_response(freq::AbstractArray, filter_params::NamedTuple)\n\nCalculates the frequency response of the offline filter. This function takes a set of frequencies and the filter's coefficients to compute how the filter amplifies or attenuates different frequency components of a signal.\n\nThe response is computed by summing the contributions of each coefficient pair based on the filter's transfer function in the frequency domain. The result is a measure of the filter's gain at each given frequency.\n\nArguments\n\nfreq: A vector of frequencies (in radians per unit time).\nfilter_params: A NamedTuple containing the filter coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\n\nReturns\n\nA vector Ghat representing the filter's frequency response at each corresponding frequency in freq.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_weight_function-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_weight_function","text":"get_weight_function(;t::AbstractArray, tref::Real, filter_params::NamedTuple, direction::String = \"both\")\n\nComputes the weighting function for the offline filter. This function calculates the filter's impulse response, which determines how much each point in the timeseries t contributes to the filtered value at a reference time tref. The weighting function is based on the provided filter_params, which contains the coefficients for the filter's impulse response.\n\nKeyword arguments\n\nt: A collection of time points in the timeseries.\ntref: The reference time at which the filter is being evaluated.\nfilter_params: A NamedTuple containing the coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\ndirection: A String indicating the direction of the filter. It can be \"both\" (default), \"forward\", or \"backward\". This determines whether the filter is applied symmetrically around tref, only to past times, or only to future times.\n\nReturns\n\nA vector of weights G, with the same dimensions as t, representing the value of the filter's impulse response at each time point relative to tref.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data-Tuple{Oceananigans.AbstractModel, NamedTuple, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data","text":"initialise_filtered_vars_from_data(model::AbstractModel, saved_original_vars::Tuple,\n                         config::AbstractConfig)\n\nInitializes the model's tracer fields, which represent the components of the filtered variables. This function sets the initial values of the filtered variables to the (scaled) first timestep of the original data. This improves the \"spin-up\" of the filter simulation by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nsaved_original_vars: A Tuple of FieldTimeSeries objects containing the original data for each variable.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model","text":"initialise_filtered_vars_from_model(model::AbstractModel,config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.jld2_to_netcdf-Tuple{String, String}","page":"Library","title":"OceananigansLagrangianFilter.Utils.jld2_to_netcdf","text":"jld2_to_netcdf(jld2_filename::String, nc_filename::String)\n\nConverts a JLD2 output file generated by an Oceananigans simulation into a standard NetCDF file. This function is useful for post-processing and for sharing data with other tools that expect the NetCDF format.\n\nThe conversion process involves the following steps:\n\nRead JLD2 data: Opens the input JLD2 file and reads the grid, time,  and all timeseries variables.\nCreate NetCDF file: Creates a new NetCDF file with a .nc extension.\nDefine dimensions: Defines NetCDF dimensions based on the grid sizes  and staggered locations (e.g., x_caa for cell centers, x_faa for  cell faces).\nDefine grid variables: Writes the grid coordinates and metadata  (e.g., Lx, Ny, Hx) as variables to the NetCDF file.\nWrite timeseries data: Iterates through each variable in the JLD2  file's timeseries, determines its location on the grid, and writes the  data to a new variable in the NetCDF file.\nAdd metadata: Adds attributes to each variable, including boundary  conditions and units, for better documentation.\n\nArguments\n\njld2_filename: A String specifying the path to the input JLD2 file.\nnc_filename: A String specifying the path for the output NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.load_data-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.load_data","text":"load_data(config::AbstractConfig)\n\nLoads the velocity and tracer data from the intermediate input file created by create_input_data_on_disk. The data for each variable is loaded as a FieldTimeSeries and returned as a single NamedTuple.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, \n\narchitecture, and backend.\n\nReturns\n\nA NamedTuple with fields velocity_data and var_data, where each field contains a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.regrid_to_mean_position!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.regrid_to_mean_position!","text":"regrid_to_mean_position!(config::AbstractConfig)\n\nRegrids the filtered data to the mean position. This function reads the combined  output file, interpolates the filtered variables to the mean position, and saves the result in new variables within the same file.\n\nThe regridding process involves the following steps:\n\nExtracts positions: The mean positions (xi_u, xi_v, xi_w) and  filtered variable data are extracted for each time step.\nHandles periodicity: For periodic dimensions (x, y, or z), the data is  padded by repeating values near the boundaries to ensure accurate  interpolation across the periodic boundaries.\nInterpolates data: A linear interpolator is used to map the filtered data  from the irregular advected positions to the original, regular grid points.\nSaves new fields: The regridded data is saved as new variables in the  combined output file, with a _Lagrangian_filtered_at_mean suffix.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and grid information.\nextra_vars_to_regrid::Tuple{Vararg{String}}=(): Optional tuple of additional filtered variable names that have been calculated by the filter and also need to be regridded. Include velocities here if needed.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params","text":"set_offline_BW2_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c, squared. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: Ghat(omega) = 1 / (1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*abs(t))*(a_i*cos(d_i * abs(t)) + b_i*sin(d_i * abs(t)))\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth squared filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_online_BW_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_online_BW_filter_params","text":"set_online_BW_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c. Note that the frequency response is not squared, like in the offline forward-backward filter, and the frequency response is not real-valued, implying a nonlinear phase shift. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: abs(Ghat(omega)) = 1 / sqrt(1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*t)* (a_i*cos(d_i * t) + b_i*sin(d_i * t))  for t>=0, and 0 for t<0.\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!","text":"sum_forward_backward_contributions!(config::AbstractConfig)\n\nCombines the output from the forward and backward filter simulations into a single output file. This function performs the final step of the offline filter algorithm by summing the contributions from each pass.\n\nThe function performs the following steps:\n\nInitializes the combined file: A new JLD2 file is created to store  the final output.\nCopies metadata and unfiltered data: The file structure, metadata,  and the original, unfiltered data are copied from the forward output file.\nSums filtered contributions: For each filtered variable, the data  from the backward output file is loaded as a FieldTimeSeries. The data  is then interpolated to match the time steps of the forward simulation,  and the two datasets are summed and written to the combined output file.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths and variable names.\nextra_filtered_var_names::Tuple{Vararg{String}}=(): Optional tuple of additional filtered variable names that have been calculated by the filter and also need to be combined.\nextra_filtered_velocity_names::Tuple{Vararg{String}}=(): Optional tuple of additional filtered velocity names that have been calculated by the filter and also need to be combined.\nextra_original_data_names::Tuple{Vararg{String}}=(): Optional tuple of additional original names that have been output and should be copied to the combined output file.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.update_input_data!-Tuple{Simulation, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.update_input_data!","text":"update_input_data!(sim::Simulation, input_data::NamedTuple)\n\nUpdates the velocity and auxiliary fields of a simulation at the current simulation time t. This function is designed to be used as a callback in an Oceananigans Simulation.\n\nThe function performs two main tasks:\n\nUpdates velocities: It sets the u, v, and w velocity fields of  the model to the corresponding data from the velocity_data  FieldTimeSeries at the current simulation time.\nUpdates auxiliary fields: It updates the auxiliary fields of the  model with the original data from the var_data FieldTimeSeries, which  are used for forcing terms.\n\nArguments\n\nsim: The Simulation object.\ninput_data: A NamedTuple containing velocity_data and var_data, where each field is a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars","text":"zero_closure_for_filtered_vars(config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/#Quick-Start","page":"Quick start","title":"ðŸš€ Quick Start","text":"","category":"section"},{"location":"quick_start/#Offline-Filtering","page":"Quick start","title":"Offline Filtering","text":"Offline filtering (whereby the data is processed after simulation time) allows for better filter shapes, since for a given reference time, data from the past and the future is available. The filters implemented here have real frequency response, and therefore have linear phase shift. If the exact properties of the filter shape are important, then offline filtering is preferable. \n\nHere is a simple example of how to filter a pre-existing dataset.\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`\n\nYou can find an example of a simple simulation of geostrophic adjustment followed by offline filtering in offline_filter_geostrophic_adjustment.jl.","category":"section"},{"location":"quick_start/#Online-Filtering","page":"Quick start","title":"Online Filtering","text":"For online filtering, you would integrate the filter directly into your Oceananigans.jl setup, using the helper functions provided. This is explained full in Online filtering implementation, and an example is given in online_filtering_geostrophic_adjustment.jl. The filtered values are then computed as your simulation runs, avoiding the need to save data at high frequency. ","category":"section"},{"location":"theory/offline_equations/#Offline-Lagrangian-filtering-equations","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'offline' configuration of OceananigansLagrangianFilter.jl. The offline scheme runs a forward pass very similar to the online configuration, before running a backward pass through the offline data and combinging the backward and forward outputs. \n\nWe compute the Lagrangian mean of some scalar f as\n\nbeginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation\n\nand optionally compute\n\nbeginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^infty alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation\n\nso that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using\n\nbeginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation\n\nWe consider even filter kernels composed of sums of exponentials of the absolute value of t:\n\nbeginequation\n    G(t) = sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right)\nendequation\n\nWe define a set of N weight functions, for even N. For k = 1N2 we have\n\nbeginalign\n    G_Ck(t) =e^-c_ktcos d_k t \n    G_Sk(t) =e^-c_ktsin d_k t \nendalign\n\nFor t0, we have\n\nbeginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign\n\nand for t0\n\nbeginalign labelbackward_G_derivs\n    G_Ck(t) = -G_Ck(-t) = c_kG_Ck(t) + d_k G_Sk(t) \n    G_Sk(t) = -G_Sk(-t) = c_kG_Sk(t) - d_k G_Ck(t) \nendalign\n\nWe then define a corresponding set of N filtered scalars\n\nbeginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign\n\nso that \n\nbeginequation\n    f_1^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation\n\nWe derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:\n\nbeginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk \nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck\nendalign\n\nThis system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0.\n\nIf we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define \n\nbeginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign\n\nso that\n\nbeginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation\n\nand\n\nbeginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign\n\nTo define perturbation equations, we set:\n\nbeginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign\n\nwhere the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by\n\nbeginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk \nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_Ck\nendalign\n\nBackward-pass equations of the same form are solved by time-reversing the velocity and field data, and changing the sign of the velocity. The final filtered field is then reconstructed by summing the forwards and backwards pass outputs at each time. ","category":"section"},{"location":"theory/online_equations/#Online-Lagrangian-filtering-equations","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'online' configuration of OceananigansLagrangianFilter.jl. They are very similar to the forward pass of the offline configuration.\n\nWe directly compute the Lagrangian mean of some scalar f as\n\nbeginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^t G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation\n\nand optionally compute\n\nbeginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t G(t-s)vb*varphi(vb*as)mathrmd s\nendequation\n\nso that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using\n\nbeginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation\n\nWe consider filter kernels composed of sums of N exponentials, where N is even.\n\nbeginequationlabelonlinekernel\n    G(t) = begincases\n    sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right) hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendequation\n\nWe require G to be normalised such that\n\nbeginequation\n    int_-infty^infty G(s)  ds = 1\nendequation\n\nor equivalently, that hatG(0) = 1. This requires that\n\nbeginequation\n    sum_n=1^N2 fraca_nc_n + b_n d_nc_n^2 + d_n^2 = 1\nendequation\n\nThis normalisation is only strictly required when we define a map that computes the trajectory mean position (map_to_mean = true in OnlineFilterConfig) but we keep the requirement for now.\n\nWe define a set of N weight functions. For k = 1N2 we have\n\nbeginalign\n    G_Ck(t) = begincases\n    e^-c_k tcos d_k thspace1cm t  0 \n    0hspace1cm t leq 0\n    endcases\n    G_Sk(t) = begincases\n    e^-c_k tsin d_k t hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendalign\n\nFor t0, we have\n\nbeginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign\n\nWe then define a corresponding set of N filtered scalars\n\nbeginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign\n\nso that \n\nbeginequationlabelreconstitutefstar\n    f^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation\n\nWe derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:\n\nbeginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk labelgCeqn\nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck labelgSeqn\nendalign\n\nThis system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0 (TODO add more on ICs, spin-up)\n\nIf we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define \n\nbeginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign\n\nso that\n\nbeginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation\n\nand\n\nbeginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign\n\nTo define perturbation equations, we set:\n\nbeginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign\n\nwhere the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by\n\nbeginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk labelxiCeqn\nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_CklabelxiSeqn\nendalign\n\nand solved with initial conditions vb*xi_Ck(vb*x0) = vb*xi_Sk(vb*x0)=0.","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Geostrophic-adjustment-with-offline-Lagrangian-filtering","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment with offline Lagrangian filtering","text":"We set up a geostrophic adjustment problem similar to Blumen (2000), JPO in a domain that is horizontally periodic.\n\nAn initially unbalanced two-dimensional front oscillates with the inertial frequency around a state of geostrophic balance, and we illustrate that we can remove the oscillations to find the mean state. Credit to Tom Cummings for work on this example.\n\nIn this example, the filtering is performed offline after the simulation.","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-the-simulation","page":"Geostrophic adjustment offline","title":"Run the simulation","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Install-dependencies","page":"Geostrophic adjustment offline","title":"Install dependencies","text":"using Oceananigans\nusing Oceananigans.Units\nusing NCDatasets\nusing Printf","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Model-parameters","page":"Geostrophic adjustment offline","title":"Model parameters","text":"Nx = 400\nNz = 80\nf = 1e-4                # Coriolis frequency [sâ»Â¹]\nL_front = 10kilometers  # Initial front width [m]\naspect_ratio = 100      # L_front/H\nRo = 0.1                # Rossby number (defines M^2)\n\nH = L_front/aspect_ratio  # Depth\nMÂ² = (Ro^2*f^2*L_front)/H # Horizontal buoyancy gradient\nÎ”b = MÂ²*L_front # Buoyancy difference across the front\nÎºh = 1e-6 # Horizontal diffusivity\nÎºv = 1e-6 # Vertical diffusivity\n\nfilename_stem = \"geostrophic_adjustment\";","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-grid","page":"Geostrophic adjustment offline","title":"Define the grid","text":"grid = RectilinearGrid(CPU(),size = (Nx, Nz),\n                       x = (-L_front/2, L_front/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))\n\n400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Closures","page":"Geostrophic adjustment offline","title":"Closures","text":"horizontal_closure = HorizontalScalarDiffusivity(Î½=Îºh, Îº=Îºh )\nvertical_closure = VerticalScalarDiffusivity(Î½=Îºv , Îº=Îºv )\nclosure = (horizontal_closure, vertical_closure);","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Tracers","page":"Geostrophic adjustment offline","title":"Tracers","text":"tracers = (:b,:T)\n\n(:b, :T)","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-model","page":"Geostrophic adjustment offline","title":"Define the model","text":"model =  NonhydrostaticModel(grid;\n                coriolis = FPlane(f = f),\n                buoyancy = BuoyancyTracer(),\n                tracers = tracers,\n                advection = WENO(),\n                closure = closure)\n\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (b, T)\nâ”œâ”€â”€ closure: Tuple with 2 closures:\nâ”‚   â”œâ”€â”€ HorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b=1.0e-6, T=1.0e-6))\nâ”‚   â””â”€â”€ VerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b=1.0e-6, T=1.0e-6))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Initialise-the-buoyancy-and-tracer","page":"Geostrophic adjustment offline","title":"Initialise the buoyancy and tracer","text":"báµ¢(x, z) = Î”b*sin(2*pi/L_front * x)\nTáµ¢(x, z) = exp(-(x/(L_front/50)).^2)\nset!(model, b= báµ¢, T= Táµ¢)","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-simulation","page":"Geostrophic adjustment offline","title":"Define the simulation","text":"simulation = Simulation(model, Î”t=20minutes, stop_time=3days)\n\nSimulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 20 minutes\nâ”œâ”€â”€ run_wall_time: 0 seconds\nâ”œâ”€â”€ run_wall_time / iteration: NaN days\nâ”œâ”€â”€ stop_time: 3 days\nâ”œâ”€â”€ stop_iteration: Inf\nâ”œâ”€â”€ wall_time_limit: Inf\nâ”œâ”€â”€ minimum_relative_step: 0.0\nâ”œâ”€â”€ callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\nâ”‚   â””â”€â”€ nan_checker => Callback of NaNChecker for u on IterationInterval(100)\nâ””â”€â”€ output_writers: OrderedDict with no entries\n\nSet an adaptive timestep\n\nconjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Î”t=20minutes)\n\nAdd a progress callback\n\nwall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Î”t))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(50))","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Set-up-the-output","page":"Geostrophic adjustment offline","title":"Set up the output","text":"u, v, w = model.velocities\nb = model.tracers.b\nT = model.tracers.T\n\n400Ã—1Ã—80 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 406Ã—1Ã—86 OffsetArray(::Array{Float64, 3}, -2:403, 1:1, -2:83) with eltype Float64 with indices -2:403Ã—1:1Ã—-2:83\n    â””â”€â”€ max=0.996101, min=8.34493e-271, mean=0.0354491\n\nOutput a jld2 file for Lagrangian filtering\n\nsimulation.output_writers[:jld2fields] = JLD2Writer(\n    model, (; b, u, v, w, T), filename = filename_stem * \".jld2\", schedule=TimeInterval(1hour), overwrite_existing=true)\n\nJLD2Writer scheduled on TimeInterval(1 hour):\nâ”œâ”€â”€ filepath: geostrophic_adjustment.jld2\nâ”œâ”€â”€ 5 outputs: (b, u, v, w, T)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 0 bytes (file not yet created)","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-simulation","page":"Geostrophic adjustment offline","title":"Run simulation","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)\n\n[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 3.170 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Î”t: 20 minutes\n[ Info:     ... simulation initialization complete (3.494 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (3.247 seconds).\n[15.28%] i: 50, t: 11 hours, wall time: 9.132 seconds, max(u): (2.205e-02, 5.272e-02, 3.914e-04) m/s, next Î”t: 6.183 minutes\n[19.31%] i: 100, t: 13.906 hours, wall time: 2.873 seconds, max(u): (2.981e-02, 2.366e-02, 5.021e-04) m/s, next Î”t: 2.795 minutes\n[22.61%] i: 150, t: 16.282 hours, wall time: 2.811 seconds, max(u): (1.448e-02, 3.717e-03, 1.989e-04) m/s, next Î”t: 3.382 minutes\n[26.86%] i: 200, t: 19.341 hours, wall time: 2.811 seconds, max(u): (1.885e-02, 6.552e-03, 3.549e-04) m/s, next Î”t: 4.420 minutes\n[30.87%] i: 250, t: 22.226 hours, wall time: 2.799 seconds, max(u): (3.049e-02, 3.460e-02, 5.432e-04) m/s, next Î”t: 2.712 minutes\n[34.20%] i: 300, t: 1.026 days, wall time: 2.744 seconds, max(u): (1.763e-02, 5.629e-02, 3.552e-04) m/s, next Î”t: 3.422 minutes\n[38.36%] i: 350, t: 1.151 days, wall time: 2.755 seconds, max(u): (1.565e-02, 5.854e-02, 3.038e-04) m/s, next Î”t: 4.141 minutes\n[42.41%] i: 400, t: 1.272 days, wall time: 2.768 seconds, max(u): (3.055e-02, 3.396e-02, 6.365e-04) m/s, next Î”t: 2.727 minutes\n[45.61%] i: 450, t: 1.368 days, wall time: 2.737 seconds, max(u): (2.307e-02, 1.076e-02, 3.970e-04) m/s, next Î”t: 3.076 minutes\n[49.47%] i: 500, t: 1.484 days, wall time: 2.753 seconds, max(u): (9.182e-03, 3.661e-03, 2.610e-04) m/s, next Î”t: 4.094 minutes\n[53.85%] i: 550, t: 1.616 days, wall time: 2.754 seconds, max(u): (2.978e-02, 2.383e-02, 6.374e-04) m/s, next Î”t: 2.965 minutes\n[57.01%] i: 600, t: 1.710 days, wall time: 2.732 seconds, max(u): (2.578e-02, 4.763e-02, 5.998e-04) m/s, next Î”t: 3.092 minutes\n[60.82%] i: 650, t: 1.825 days, wall time: 2.758 seconds, max(u): (5.830e-03, 6.150e-02, 1.671e-04) m/s, next Î”t: 3.741 minutes\n[65.28%] i: 700, t: 1.958 days, wall time: 2.757 seconds, max(u): (2.783e-02, 4.469e-02, 7.864e-04) m/s, next Î”t: 2.994 minutes\n[68.51%] i: 750, t: 2.055 days, wall time: 2.726 seconds, max(u): (2.840e-02, 2.019e-02, 7.026e-04) m/s, next Î”t: 2.800 minutes\n[72.01%] i: 800, t: 2.160 days, wall time: 2.739 seconds, max(u): (1.031e-02, 6.012e-03, 1.518e-04) m/s, next Î”t: 3.727 minutes\n[76.49%] i: 850, t: 2.295 days, wall time: 2.748 seconds, max(u): (2.391e-02, 1.160e-02, 7.266e-04) m/s, next Î”t: 4.419 minutes\n[80.12%] i: 900, t: 2.404 days, wall time: 2.709 seconds, max(u): (2.944e-02, 3.850e-02, 8.380e-04) m/s, next Î”t: 2.831 minutes\n[83.57%] i: 950, t: 2.507 days, wall time: 2.733 seconds, max(u): (1.288e-02, 5.856e-02, 5.939e-04) m/s, next Î”t: 3.425 minutes\n[87.88%] i: 1000, t: 2.637 days, wall time: 2.744 seconds, max(u): (2.045e-02, 5.464e-02, 7.651e-04) m/s, next Î”t: 4.074 minutes\n[91.73%] i: 1050, t: 2.752 days, wall time: 2.707 seconds, max(u): (3.010e-02, 2.809e-02, 1.100e-03) m/s, next Î”t: 2.759 minutes\n[95.10%] i: 1100, t: 2.853 days, wall time: 2.730 seconds, max(u): (1.714e-02, 8.333e-03, 4.073e-04) m/s, next Î”t: 3.453 minutes\n[99.29%] i: 1150, t: 2.979 days, wall time: 2.755 seconds, max(u): (1.560e-02, 8.750e-03, 8.093e-04) m/s, next Î”t: 4.178 minutes\n[ Info: Simulation is stopping after running for 1.178 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation completed in 1.179 minutes\n","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Perform-Lagrangian-filtering","page":"Geostrophic adjustment offline","title":"Perform Lagrangian filtering","text":"Now we set up and run the offline Lagrangian filter on the output of the above simulation. This could be performed in a different script (with appropriate import of Oceananigans.Units and CUDA if needed)\n\nusing OceananigansLagrangianFilter","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Set-up-the-filter-configuration","page":"Geostrophic adjustment offline","title":"Set up the filter configuration","text":"filter_config = OfflineFilterConfig(original_data_filename=\"geostrophic_adjustment.jld2\", # Where the original simulation output is\n                                    output_filename = \"geostrophic_adjustment_offline_filtered.jld2\", # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"w\",\"v\"), # Velocities to use for remapping\n                                    architecture = CPU(), # CPU() or GPU(), if GPU() make sure you have CUDA.jl installed and imported\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    output_netcdf = true, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\nOfflineFilterConfig(\"geostrophic_adjustment.jld2\", (\"T\", \"b\"), (\"u\", \"w\", \"v\"), 0.0, 259200.0, 259200.0, CPU(), 3600.0, (a1 = 1.767766952966369e-5, b1 = 1.767766952966369e-5, c1 = 3.535533905932738e-5, d1 = 3.535533905932738e-5, N_coeffs = 1), 1200.0, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"geostrophic_adjustment_offline_filtered.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ”‚   â””â”€â”€ buffer_scheme: Centered(order=2)\nâ””â”€â”€ advecting_velocity_scheme: Centered(order=4), 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25, \"offline\", \"\")","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-the-offline-Lagrangian-filter","page":"Geostrophic adjustment offline","title":"Run the offline Lagrangian filter","text":"run_offline_Lagrangian_filter(filter_config)\n\n[ Info: Loaded data from geostrophic_adjustment.jld2\n[ Info: Created original variables: (:T, :b)\n[ Info: Created filtered variables: (:T_C1, :b_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :T_S1, :b_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1)\n[ Info: Created forcing for filtered variables\n[ Info: Created model\n[ Info: Initialised filtered variables\n[ Info: Defined outputs\n[ Info: Defined simulation\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (6.233 minutes)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (27.527 seconds).\n[ Info: Simulation time: 7.200 hours\n[ Info: Simulation time: 14.400 hours\n[ Info: Simulation time: 21.600 hours\n[ Info: Simulation time: 1.200 days\n[ Info: Simulation time: 1.500 days\n[ Info: Simulation time: 1.800 days\n[ Info: Simulation time: 2.100 days\n[ Info: Simulation time: 2.400 days\n[ Info: Simulation time: 2.700 days\n[ Info: Simulation is stopping after running for 18.425 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation time: 3 days\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (1.089 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.099 seconds).\n[ Info: Simulation time: 7.200 hours\n[ Info: Simulation time: 14.400 hours\n[ Info: Simulation time: 21.600 hours\n[ Info: Simulation time: 1.200 days\n[ Info: Simulation time: 1.500 days\n[ Info: Simulation time: 1.800 days\n[ Info: Simulation time: 2.100 days\n[ Info: Simulation time: 2.400 days\n[ Info: Simulation time: 2.700 days\n[ Info: Simulation is stopping after running for 12.210 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation time: 3 days\n[ Info: Combined forward and backward contributions into geostrophic_adjustment_offline_filtered.jld2\n[ Info: Assuming velocities normal to z boundaries are zero\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file geostrophic_adjustment_offline_filtered.jld2\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable b\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable w\n[ Info: Computing Eulerian filter for variable v\n[ Info: Wrote NetCDF file to geostrophic_adjustment_offline_filtered.nc\n","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Visualisation","page":"Geostrophic adjustment offline","title":"Visualisation","text":"using CairoMakie\n\nNow we animate the results. First, the buoyancy:\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"b\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"b_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-1e-4, 1e-4))\n\n\ntitle = @lift \"Buoyancy, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_buoyancy_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"geostrophic_adjustment_filtered_buoyancy_movie_offline.mp4\"\n\n(Image: )\n\nThen the tracer:\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer concentration, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_tracer_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"geostrophic_adjustment_filtered_tracer_movie_offline.mp4\"\n\n(Image: )\n\nWe see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures.\n\nThen the velocity into the page, v:\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"v\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"v_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-0.05, 0.05))\n\n\ntitle = @lift \"Velocity v, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_v_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"geostrophic_adjustment_filtered_v_movie_offline.mp4\"\n\n(Image: )\n\nIn this case, the Lagrangian filtered velocity fields differ from the raw fields, as expected, since velocity is not a conservative field.\n\nWe remove these files to keep things tidy, keep them for analysis if desired\n\nrm(filename_stem * \".jld2\")\nrm(filter_config.output_filename)\nrm(filter_config.output_filename[1:end-5] * \".nc\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Geostrophic-adjustment-with-online-Lagrangian-filtering","page":"Geostrophic adjustment online","title":"Geostrophic adjustment with online Lagrangian filtering","text":"We set up a geostrophic adjustment problem similar to Blumen (2000), JPO in a domain that is horizontally periodic.\n\nAn initially unbalanced two-dimensional front oscillates with the inertial frequency around a state of geostrophic balance, and we illustrate that we can remove the oscillations to find the mean state. Thanks to Tom Cummings for work on this example.\n\nIn this example, the filtering is performed online during the simulation.","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Load-dependencies","page":"Geostrophic adjustment online","title":"Load dependencies","text":"using OceananigansLagrangianFilter # Gives access to all Oceananigans functions too\nusing Oceananigans.Units\nusing NCDatasets\nusing Printf","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Model-parameters","page":"Geostrophic adjustment online","title":"Model parameters","text":"Nx = 400\nNz = 80\nf = 1e-4                # Coriolis frequency [sâ»Â¹]\nL_front = 10kilometers  # Initial front width [m]\naspect_ratio = 100      # L_front/H\nRo = 0.1                # Rossby number (defines M^2)\n\n\nH = L_front/aspect_ratio  # Depth\nMÂ² = (Ro^2*f^2*L_front)/H # Horizontal buoyancy gradient\nÎ”b = MÂ²*L_front # Buoyancy difference across the front\nÎºh = 1e-6 # Horizontal diffusivity\nÎºv = 1e-6 # Vertical diffusivity\n\nfilename_stem = \"geostrophic_adjustment_online_filtered\";","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Grid","page":"Geostrophic adjustment online","title":"Grid","text":"grid = RectilinearGrid(CPU(),size = (Nx, Nz),\n                       x = (-L_front/2, L_front/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))\n\n400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-model-tracers","page":"Geostrophic adjustment online","title":"Define model tracers","text":"tracers = (:b,:T);","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-model-forcing","page":"Geostrophic adjustment online","title":"Define model forcing","text":"forcing = NamedTuple();","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-filter-configuration","page":"Geostrophic adjustment online","title":"Define filter configuration","text":"filter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = filename_stem * \".jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"),\n                                    velocity_names = (\"u\",\"w\",\"v\"),\n                                    N = 2,\n                                    freq_c = f/2)\n\nOnlineFilterConfig(400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25, \"geostrophic_adjustment_online_filtered.jld2\", (\"b\", \"T\"), (\"u\", \"w\", \"v\"), (a1 = 1.421067568548072e-20, b1 = -7.071067811865475e-5, c1 = 3.535533905932738e-5, d1 = -3.535533905932738e-5, N_coeffs = 1), true, true, 5, \"online\", \"\")","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Create-the-filtered-variables-these-will-be-tracers-in-the-model","page":"Geostrophic adjustment online","title":"Create the filtered variables - these will be tracers in the model","text":"filtered_vars = create_filtered_vars(filter_config)\n\n(:b_C1, :T_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :b_S1, :T_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-to-the-existing-tracers","page":"Geostrophic adjustment online","title":"Add to the existing tracers","text":"tracers = (filtered_vars..., tracers...)\n\n(:b_C1, :T_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :b_S1, :T_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1, :b, :T)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Create-forcing-for-these-filtered-variables","page":"Geostrophic adjustment online","title":"Create forcing for these filtered variables","text":"filter_forcing = create_forcing(filtered_vars, filter_config);","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-these-to-the-existing-forcing","page":"Geostrophic adjustment online","title":"Add these to the existing forcing","text":"forcing = merge(forcing, filter_forcing);","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-closures","page":"Geostrophic adjustment online","title":"Define closures","text":"If the model uses a closure, we use a helper function to set filtered variable closures to zero (unless we set filtered variable closures to zero, the default closure will apply to all tracers).\n\nzero_filtered_var_closure = zero_closure_for_filtered_vars(filter_config)\nhorizontal_closure = HorizontalScalarDiffusivity(Î½=Îºh, Îº=merge((T=Îºh, b= Îºh),zero_filtered_var_closure) )\nvertical_closure = VerticalScalarDiffusivity(Î½=Îºv , Îº=merge((T=Îºv, b= Îºv),zero_filtered_var_closure) )\nclosure = (horizontal_closure, vertical_closure);","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-the-model","page":"Geostrophic adjustment online","title":"Define the model","text":"model =  NonhydrostaticModel(grid;\n                coriolis = FPlane(f = f),\n                buoyancy = BuoyancyTracer(),\n                tracers = tracers,\n                forcing = forcing,\n                advection = WENO(),\n                closure = closure)\n\nNonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (b_C1, T_C1, xi_u_C1, xi_w_C1, xi_v_C1, b_S1, T_S1, xi_u_S1, xi_w_S1, xi_v_S1, b, T)\nâ”œâ”€â”€ closure: Tuple with 2 closures:\nâ”‚   â”œâ”€â”€ HorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b_C1=0.0, T_C1=0.0, xi_u_C1=0.0, xi_w_C1=0.0, xi_v_C1=0.0, b_S1=0.0, T_S1=0.0, xi_u_S1=0.0, xi_w_S1=0.0, xi_v_S1=0.0, b=1.0e-6, T=1.0e-6))\nâ”‚   â””â”€â”€ VerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b_C1=0.0, T_C1=0.0, xi_u_C1=0.0, xi_w_C1=0.0, xi_v_C1=0.0, b_S1=0.0, T_S1=0.0, xi_u_S1=0.0, xi_w_S1=0.0, xi_v_S1=0.0, b=1.0e-6, T=1.0e-6))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Initialise-tracers","page":"Geostrophic adjustment online","title":"Initialise tracers","text":"Model buoyancy and tracers\n\nbáµ¢(x, z) = Î”b*sin(2*pi/L_front * x)\nTáµ¢(x, z) = exp(-(x/(L_front/50)).^2)\nset!(model, b= báµ¢, T= Táµ¢)\n\nSet appropriate initial conditions for the filtered variables based on the actual variables\n\ninitialise_filtered_vars_from_model(model, filter_config)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-the-simulation","page":"Geostrophic adjustment online","title":"Define the simulation","text":"simulation = Simulation(model, Î”t=20minutes, stop_time=3days)\n\nSimulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 20 minutes\nâ”œâ”€â”€ run_wall_time: 0 seconds\nâ”œâ”€â”€ run_wall_time / iteration: NaN days\nâ”œâ”€â”€ stop_time: 3 days\nâ”œâ”€â”€ stop_iteration: Inf\nâ”œâ”€â”€ wall_time_limit: Inf\nâ”œâ”€â”€ minimum_relative_step: 0.0\nâ”œâ”€â”€ callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\nâ”‚   â””â”€â”€ nan_checker => Callback of NaNChecker for u on IterationInterval(100)\nâ””â”€â”€ output_writers: OrderedDict with no entries","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Set-an-adaptive-timestep","page":"Geostrophic adjustment online","title":"Set an adaptive timestep","text":"conjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Î”t=20minutes)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-a-progress-callback","page":"Geostrophic adjustment online","title":"Add a progress callback","text":"wall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Î”t))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(50))","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Set-up-the-outputs","page":"Geostrophic adjustment online","title":"Set up the outputs","text":"Create filtered outputs:\n\noutputs = create_output_fields(model, filter_config);\n\nAdd in original variables if needed:\n\noutputs[\"b\"] = model.tracers.b;\noutputs[\"T\"] = model.tracers.T;\noutputs[\"u\"] = model.velocities.u;\noutputs[\"v\"] = model.velocities.v;\noutputs[\"w\"] = model.velocities.w;\n\nOutput a .jld2 file:\n\nsimulation.output_writers[:jld2fields] = JLD2Writer(\n    model, outputs, filename=filter_config.output_filename, schedule=TimeInterval(1hour), overwrite_existing=true)\n\nJLD2Writer scheduled on TimeInterval(1 hour):\nâ”œâ”€â”€ filepath: geostrophic_adjustment_online_filtered.jld2\nâ”œâ”€â”€ 13 outputs: (xi_u, T, b, b_Lagrangian_filtered, xi_v, xi_w, v, w, v_Lagrangian_filtered, w_Lagrangian_filtered, T_Lagrangian_filtered, u, u_Lagrangian_filtered)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 0 bytes (file not yet created)","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Run-the-simulation","page":"Geostrophic adjustment online","title":"Run the simulation","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)\n\n[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 25.564 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Î”t: 20 minutes\n[ Info:     ... simulation initialization complete (6.036 minutes)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (20.778 seconds).\n[15.28%] i: 50, t: 11 hours, wall time: 8.922 minutes, max(u): (2.205e-02, 5.272e-02, 3.914e-04) m/s, next Î”t: 6.183 minutes\n[19.31%] i: 100, t: 13.906 hours, wall time: 2.768 minutes, max(u): (2.981e-02, 2.366e-02, 5.021e-04) m/s, next Î”t: 2.795 minutes\n[22.61%] i: 150, t: 16.282 hours, wall time: 2.690 minutes, max(u): (1.448e-02, 3.717e-03, 1.989e-04) m/s, next Î”t: 3.382 minutes\n[26.86%] i: 200, t: 19.341 hours, wall time: 2.871 minutes, max(u): (1.885e-02, 6.552e-03, 3.549e-04) m/s, next Î”t: 4.420 minutes\n[30.87%] i: 250, t: 22.226 hours, wall time: 2.725 minutes, max(u): (3.049e-02, 3.460e-02, 5.432e-04) m/s, next Î”t: 2.712 minutes\n[34.20%] i: 300, t: 1.026 days, wall time: 2.562 minutes, max(u): (1.763e-02, 5.629e-02, 3.552e-04) m/s, next Î”t: 3.422 minutes\n[38.36%] i: 350, t: 1.151 days, wall time: 2.552 minutes, max(u): (1.565e-02, 5.854e-02, 3.038e-04) m/s, next Î”t: 4.141 minutes\n[42.41%] i: 400, t: 1.272 days, wall time: 2.526 minutes, max(u): (3.055e-02, 3.396e-02, 6.365e-04) m/s, next Î”t: 2.727 minutes\n[45.61%] i: 450, t: 1.368 days, wall time: 2.525 minutes, max(u): (2.307e-02, 1.076e-02, 3.970e-04) m/s, next Î”t: 3.076 minutes\n[49.47%] i: 500, t: 1.484 days, wall time: 2.516 minutes, max(u): (9.182e-03, 3.661e-03, 2.610e-04) m/s, next Î”t: 4.094 minutes\n[53.85%] i: 550, t: 1.616 days, wall time: 2.534 minutes, max(u): (2.978e-02, 2.383e-02, 6.374e-04) m/s, next Î”t: 2.965 minutes\n[57.01%] i: 600, t: 1.710 days, wall time: 2.525 minutes, max(u): (2.578e-02, 4.763e-02, 5.998e-04) m/s, next Î”t: 3.092 minutes\n[60.82%] i: 650, t: 1.825 days, wall time: 2.522 minutes, max(u): (5.830e-03, 6.150e-02, 1.671e-04) m/s, next Î”t: 3.741 minutes\n[65.28%] i: 700, t: 1.958 days, wall time: 2.527 minutes, max(u): (2.783e-02, 4.469e-02, 7.864e-04) m/s, next Î”t: 2.994 minutes\n[68.51%] i: 750, t: 2.055 days, wall time: 2.523 minutes, max(u): (2.840e-02, 2.019e-02, 7.026e-04) m/s, next Î”t: 2.800 minutes\n[72.01%] i: 800, t: 2.160 days, wall time: 2.528 minutes, max(u): (1.031e-02, 6.012e-03, 1.518e-04) m/s, next Î”t: 3.727 minutes\n[76.49%] i: 850, t: 2.295 days, wall time: 2.522 minutes, max(u): (2.391e-02, 1.160e-02, 7.266e-04) m/s, next Î”t: 4.419 minutes\n[80.12%] i: 900, t: 2.404 days, wall time: 2.543 minutes, max(u): (2.944e-02, 3.850e-02, 8.380e-04) m/s, next Î”t: 2.831 minutes\n[83.57%] i: 950, t: 2.507 days, wall time: 2.518 minutes, max(u): (1.288e-02, 5.856e-02, 5.939e-04) m/s, next Î”t: 3.425 minutes\n[87.88%] i: 1000, t: 2.637 days, wall time: 2.508 minutes, max(u): (2.045e-02, 5.464e-02, 7.651e-04) m/s, next Î”t: 4.074 minutes\n[91.73%] i: 1050, t: 2.752 days, wall time: 2.505 minutes, max(u): (3.010e-02, 2.809e-02, 1.100e-03) m/s, next Î”t: 2.759 minutes\n[95.10%] i: 1100, t: 2.853 days, wall time: 2.534 minutes, max(u): (1.714e-02, 8.333e-03, 4.073e-04) m/s, next Î”t: 3.453 minutes\n[99.29%] i: 1150, t: 2.979 days, wall time: 2.531 minutes, max(u): (1.560e-02, 8.750e-03, 8.093e-04) m/s, next Î”t: 4.178 minutes\n[ Info: Simulation is stopping after running for 1.099 hours.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation completed in 1.100 hours\n","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-regrid-to-mean-position","page":"Geostrophic adjustment online","title":"Option to regrid to mean position","text":"if filter_config.map_to_mean\n    regrid_to_mean_position!(filter_config)\nend\n\n[ Info: Assuming velocities normal to z boundaries are zero\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file geostrophic_adjustment_online_filtered.jld2\n","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-calculate-Eulerian-filter-too","page":"Geostrophic adjustment online","title":"Option to calculate Eulerian filter too","text":"compute_Eulerian_filter!(filter_config);\n\n[ Info: Computing Eulerian filter for variable b\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable w\n[ Info: Computing Eulerian filter for variable v\n","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-add-a-shifted-time-coordinate","page":"Geostrophic adjustment online","title":"Option to add a shifted time coordinate","text":"compute_time_shift!(filter_config)\n\n[ Info: Wrote time shift data to new group timeseries/t_shifted in file geostrophic_adjustment_online_filtered.jld2\n","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-output-a-final-NetCDF-file","page":"Geostrophic adjustment online","title":"Option to output a final NetCDF file","text":"jld2_to_netcdf(filename_stem * \".jld2\", filename_stem * \".nc\")\n\n[ Info: Wrote NetCDF file to geostrophic_adjustment_online_filtered.nc\n","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Animate-the-results,-buoyancy-first:","page":"Geostrophic adjustment online","title":"Animate the results, buoyancy first:","text":"using CairoMakie\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"b\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"b_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-1e-4, 1e-4))\n\n\ntitle = @lift \"Buoyancy, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_buoyancy_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"geostrophic_adjustment_filtered_buoyancy_movie_online.mp4\"\n\n(Image: )","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/#Then-plot-the-tracer-concentration:","page":"Geostrophic adjustment online","title":"Then plot the tracer concentration:","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer concentration, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_tracer_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n[ Info: Making an animation\n\n\n(Image: )\n\nWe see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures. In comparison to the offline filtering example, the online filter does a slightly worse job removing the oscillations in the 'Lagrangian filtered at mean' field, since the filter is a more optimal low-pass.\n\nThen the velocity into the page, v:\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"v\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"v_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-0.05, 0.05))\n\n\ntitle = @lift \"Velocity v, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_v_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"geostrophic_adjustment_filtered_v_movie_online.mp4\"\n\n(Image: )\n\nIn this case, the Lagrangian filtered velocity fields differ from the raw fields, as expected, since velocity is not a conservative field.\n\n#Â We remove these files to keep things tidy, keep them for analysis if desired\nrm(filename_stem * \".jld2\")\nrm(filename_stem * \".nc\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Choosing-offline-filters","page":"Choosing offline filters","title":"Choosing offline filters","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#General-form","page":"Choosing offline filters","title":"General form","text":"The offline filter uses weight functions of the form\n\nG(t) = sum_n=1^N2 e^-c_nt(a_ncosd_nt + b_nsind_nt)\n\nwhere a_n, b_n, c_n, and d_n are real scalars, c_n  0, and N should be even. N is the number of exponentials that are summed to form the weight function, and should be even as the exponentials come in complex conjugate pairs to keep calculations real. These coefficients can be provided to OfflineFilterConfig inside the NamedTuple filter_params.\n\nfilter_params = (a1 = 0.5, b1 = 0.5, c1 = 1, d1 = 1)\n\n\nFor the weight function to be normalised (so that the mean of a constant is the constant itself), these coefficients must be chosen such that\n\nsum_n=1^N2 fraca_nc_n + b_n d_nc_n^2 +d_n^2 = frac12\n\nUn-normalised filters can be used, but map_to_mean will be set to false as the maps no longer make sense. \n\nFor N2 sets of coefficients, the weight function is composed of N exponentials, and N filtered tracers are needed to find the Lagrangian mean of each tracer. The number of equations that the filtering simulation solves is therefore linear in N, so beware making N too large. ","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Exponential","page":"Choosing offline filters","title":"Exponential","text":"For the special case of one (real) exponential, N can be set to 1 (this is the only exception toN being even). The parameters a_1 and c_1 can then be provided:\n\nfilter_params = (a1 = 0.5, c1 = 1)\n\ngiving \n\nG(t) = a_1 e^-c_1 t","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Butterworth-(squared)","page":"Choosing offline filters","title":"Butterworth (squared)","text":"Instead of providing the individual parameters in filter_params, the user can provide N (the filter order, which should be even or 1) and freq_c (the cut-off frequency) to use a filter with frequency response \n\nbeginequation\n    hatG(omega) = frac11 + left(omegaomega_cright)^2N\nendequation \n\nThis frequency response is the squared amplitude of that of the Butterworth order-N filter.\n\nThe filter coefficients are set as\n\nbeginalign\n    a_n = fracomega_cNsinfracpi2N(2n-1) \n    b_n = fracomega_cNcosfracpi2N(2n-1) \n    c_n = omega_csinfracpi2N(2n-1) \n    d_n = omega_ccosfracpi2N(2n-1)\nendalign","category":"section"},{"location":"theory/filtering_PDEs/#Background:-PDEs-for-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/#Introduction","page":"Background: PDEs for Lagrangian filtering","title":"Introduction","text":"Lagrangian averaging (or, equivalently, Lagrangian filtering) is an effective way to decompose complex multi-scale flows into wave and mean components, as it allows separation based on intrinsic frequency of processes, that is, frequency in the frame of the flow. \n\nLagrangian means are usually found by seeding virtual particles in numerical simulations and keeping track of their positions. However, various methods for calculating Lagrangian means through the solution of PDEs have recently been developed (Kafiabad and Vanneste, 2023; Baker et al., 2025; Minz et al., 2025), removing the need for particle tracking. These PDE-based methods are flexible, and allow various ways of computing the Lagrangian mean dependent on the use case. Some considerations include:\n\nShould the filtering be performed online (at simulation time) or offline (after simulation time, using saved data)?\nHow important is the filter shape - can we get away with a less strict low-pass?\nHow often do we need to find the Lagrangian mean? Once per averaging interval, or at every time? \n\nThese considerations will determine how the Lagrangian average should be performed, and how OceananigansLagrangianFilter is used. \n\nBefore describing how to find Lagrangian averages with PDEs, we first describe the simpler case of finding Eulerian averages with ODEs. ","category":"section"},{"location":"theory/filtering_PDEs/#ODEs-for-Eulerian-time-averages","page":"Background: PDEs for Lagrangian filtering","title":"ODEs for Eulerian time averages","text":"We consider some scalar function f(t) (for now neglecting the spatial dimension), from which we would like to obtain barf, its low-pass filter. We know f only at the current simulation time t, and it can only depend on past times by causality, so we must have \n\nbeginequation\n    barf(t) = int_-infty^t K(ts) f(s)mathrmd s\nendequation\n\nfor some weight function K(ts), whose shape (a function of s) could depend on the current time t. \n\nWe look for an evolution equation of barf and take the time derivative, finding:\n\nbeginequationlabeltime_evol1\n    dotbarf(t) = K(tt) f(t) + int_-infty^t fracpartialpartial tK(ts) mathrmd s\nendequation\n\nTo be able to close this equation so that it only depends on information available at the current time, we need either:\n\nfracpartialpartial tK(ts) = alpha(t)K(ts), so that the integral in \\eqref{time_evol1} can be expressed in terms of barf.\nfracpartialpartial tK(ts) = 0, so that K(ts) equiv G(s), and the weight function G(s) does not change as t increases. \n\nThese two options give rise to different schemes. ","category":"section"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-moving-exponential-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with moving exponential weight functions","text":"In this case, the most general weight function satisfies fracpartialpartial tK(ts) = alpha(t)K(ts). However, we additionally constrain the weight function by imposing that although the reference time of the weight function changes with the simulation time  t, it's shape should not, so K(ts) = G(t-s), and barf is a convolution between the impulse response G(t) and f. This then implies that \n\nbeginequation\n    K(ts) equiv G(t -s) = alpha e^-alpha (t -s)\nendequation\n\nfor some constant alpha. With this special exponential weight function, the normalisation \n\nbeginequation\n    int_-infty^t G(t - s)  ds = 1\nendequation\n\nholds at all times so barf describes the exponential mean at all times (after some initial spin-up), and is given by\n\nbeginequationlabelexponentialODE\n    dotbarf(t) = alpha(f(t) - barf(t))\nendequation\n\nTherefore, when the weight function G(t) is exponential (or composed of a small number of exponentials, as will be descibed later) equation \\eqref{exponentialODE} can be solved alongside the governing equation for f(t) and the exponential mean found 'on-the-fly'. The methods that are currently implemented in OceananigansLagrangianFilter are based on sums of exponential weight functions.","category":"section"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-fixed-arbitrary-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with fixed arbitrary weight functions","text":"In this case, the weight function G(s) doesn't shift with the simulation time t, so the low pass variable\n\nbeginequation\n    barf(t) = int_-infty^t G(s) f(s)mathrmd s\nendequation\n\nonly truly describes the low-pass filtered field as t rightarrow infty. The weight function G(s) can take any form, but should satisfy the normalisation \n\nbeginequation\n    int_-infty^infty G(s) mathrmd s = 1\nendequation\n\nIn reality, we consider some finite interval t^* - T2 t^* + T2 for some reference time t^*, and consider\n\nbeginequation\n    barf(tt^*) = int_t^* - T2^t G(t^* - s) f(s)mathrmd s\nendequation\n\nwhere barf(t^* + T2t^*) is our desired output, G(t) is only non-zero on -T2T2, and barf satisfies\n\nbeginequation\n    dotbarf(tt^*) = G(t^* - t)f(t)\nendequation\n\nWe can think of t^*_i = T2 + iT, where T is the averaging interval, and i in 012 as defining a coarse time, and solve for the mean at each t^*_i by reinitialising barf after each time T so that barf(iTt^*_i) = 0.\n\nMethods for filtering with arbitrary weight functions in this way are described in Baker et al. (2025). These are not yet implemented in OceananigansLagrangianFilter, but raise an issue on our github if you're interested in using these methods. ","category":"section"},{"location":"theory/filtering_PDEs/#Online-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Online exponential Lagrangian filtering","text":"Here, we demonstrate the how the (single) exponential Lagrangian mean can be found online. This is the basic idea behind OceananigansLagrangianFilter, and is a simplified version of the exponential Lagrangian averaging described in (Minz et al., 2025). We define (see Lagrangian averaging for general definitions):\n\nbeginequationlabelsingleexpfstar\n    f^*(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)f(vb*varphi(vb*as)s)mathrmd s\nendequation\n\nfor some inverse timescale alpha. Taking the time derivative of \\eqref{singleexpfstar} at fixed vb*a, and using the chain rule, gives\n\nbeginequation\n    fracpartial f^*partial t(vb*varphi(vb*at)t) + fracpartial vb*varphipartial t(vb*at)cdot nabla f^*(vb*varphi(vb*at)t) = alpha(f(vb*varphi(vb*at)t) - f^*(vb*varphi(vb*at)t))\nendequation\n\nSetting vb*varphi(vb*at) = vb*x, and noting that fracpartial vb*varphipartial t (vb*at)= vb*u(vb*varphi(vb*at)t) by definition of the flow map, we have\n\nbeginequationlabelfstareqnsingleexp\n    fracpartial f^*partial t(vb*xt) + vb*u cdotnabla f^*(vb*xt) = alpha(f(vb*xt) - f^*(vb*xt))\nendequation\n\nThis equation can then be solved alongside the dynamical equations of the simulation (which will determine f and vb*u) to find f^* at all times (after some suitable spin-up period). \n\nIf we also want to find the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging), we define a map\n\nbeginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation\n\nTaking the time derivative, we find (c.f. \\eqref{fstareqnsingleexp})\n\nbeginequationlabelXieqnsingleexp\n    fracpartial vb*Xipartial t(vb*xt) + vb*u cdotnabla vb*Xi(vb*xt) = alpha(vb*x - vb*Xi(vb*xt))\nendequation\n\nDefining a perturbation vb*xi(vb*xt) = vb*Xi(vb*xt) - vb*x, we then have\n\nbeginequationlabelxieqnsingleexp\n    fracpartial vb*xipartial t(vb*xt) + vb*u cdotnabla vb*xi(vb*xt) = - vb*u - alpha vb*Xi(vb*xt)\nendequation\n\nAfter having solved \\eqref{fstareqnsingleexp} for f^* and \\eqref{xieqnsingleexp} for vb*xi, the relation\n\nbeginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation\n\ncan be used to recover barf^mathrmL by interpolation.","category":"section"},{"location":"theory/filtering_PDEs/#Offline-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Offline exponential Lagrangian filtering","text":"While the exponential formulation is efficient as it finds the mean at all times, it limits the possible weight functions, and in particular limits us to causal averages, which depend at any time only on past data. For this reason, we also develop an approach to exponential filtering that combines a 'forward' exponential average (as in \\eqref{fstareqnsingleexp}) with a 'backward' exponential pass. \n\nFor \\eqref{fstareqnsingleexp} to be run `backwards', the filtering must be performed offline and the data therefore saved at wave-resolving resolution. The forward and backward outputs are summed to give a total output with a more desirable effective filter shape, at the expense of the necessity of saving data. \n\nThe goal is to find \n\nbeginequation\n    f^*(vb*varphi(vb*at) t) = int_-infty^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation\n\nwhere G(t) is even such that G(t) equiv G(t). \n\nThis property means that the weight function will be centred on the reference time t, and the frequency response of this filter will be real. Such filters have linear phase shift (or, in this case, zero phase shift,* since G is symmetric about t=0). This means that the phases of frequencies in the pass-band are not modified, in contrast to filters like the single sided exponential used in Online Lagrangian filtering. See Choosing online filters for more explanation of weight functions.\n\nFor a single exponential (as opposed to sums of exponentials, to be introduced in Online Lagrangian filtering equations and Offline Lagrangian filtering equations),\n\nbeginequation\nG(t-s) = fracalpha2 e^-alphat-s\nendequation\n\ni.e. a `double sided exponential'.\n\nOn the forward pass (which can be performed either 'online' at the same time as the simulation, or `offline' on saved data - our implementation does this offline since data must be saved for the backward pass anyway) we calculate\n\nbeginequation\n    f^*_1(vb*varphi(vb*at) t) = int_-infty^t G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation\n\nand on the backward pass (which must be performed offline) we calculate \n\nbeginequationlabelf2star\n    f^*_2(vb*varphi(vb*at) t) = int_t^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation\n\nsuch that f^* = f^*_1 + f^*_2.\n\nThe forward equation is identical to the online scheme \\eqref{fstareqnsingleexp}, aside from a factor of two to ensure that the normalisation of the weight function still holds:\n\nbeginequationlabelf1stareqnsingleexp\n    fracpartial f^*_1partial t(vb*xt) + vb*u cdotnabla f^*_1(vb*xt) = fracalpha2(f(vb*xt) - f^*_1(vb*xt))\nendequation\n\nThe backward equation is found by first taking the time derivative of \\eqref{f2star} to give\n\nbeginequationlabelf2stareqnsingleexp\n    fracpartial f^*_2partial t(vb*xt) + vb*u cdotnabla f^*_2(vb*xt) = -fracalpha2(f(vb*xt) - f^*(vb*xt))\nendequation\n\nthen setting tildet = T - t, where T is the total simulation time (or end of the desired averaging interval), to give\n\nbeginequationlabelf2stareqnsingleexp_timereversed\n    fracpartial f^*_2partial tildet(vb*xT - tildet) - vb*u cdotnabla f^*_2(vb*xT - tildet) = fracalpha2(f(vb*xT - tildet) - f^*(vb*xT - tildet))\nendequation\n\nDefining tildef^*_2(vb*xtildet) = f^*_2(vb*xT-tildet), tildef(vb*xtildet) = f(vb*xT-tildet), and tildevb*u(vb*xtildet) = vb*u(vb*xT-tildet), we then have\n\nbeginequationlabelf2stareqnsingleexp_tilde\n    fracpartial tildef^*_2partial tildet(vb*xtildet) + tildevb*u cdotnabla tildef^*_2(vb*xtildet) = fracalpha2(f(vb*xtildet) - tildef^*(vb*xtildet))\nendequation\n\nwhich is equivalent to \\eqref{f1stareqnsingleexp} solved backwards with negated velocities. Equations for the forward and backward maps vb*Xi_1 and vb*Xi_2 (c.f. \\eqref{Xidefonline}) can be found similarly by setting f to the identity in \\eqref{fstareqnsingleexp} and \\eqref{f2stareqnsingleexp_tilde}.\n\nHaving found f_1^* on the forward pass, and tildef_2^* on the backward pass, we then calculate \n\nbeginequation\nf^*(vb*xt) = f_1^*(vb*xt) + tildef_2^*(vb*xT-t)\nendequation","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-and-Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian averaging","text":"The Eulerian weighted temporal mean of some scalar f is defined as\n\nbeginequation\nlabelfbarEdef\n    barf^mathrmE(vb*xt) = int_-infty^infty G(t-s)f(vb*xs)  mathrmd s\nendequation\n\nwhere G(t) is some weight function, also referred to as a filter kernel or impulse response. The Fourier transform of G(t) is denoted hatG(omega), and is the frequency response of the weight function. Here, we will generally want G(t) to represent a low-pass filter, which retains the low frequencies and removes high frequencies. For example, two possible choices of weight function are \n\nTop-hat impulse response: G(t) = begincases 1T  hspace1cm -T2  t  T2  0 hspace1cm mathrmotherwiseendcases\nTop-hat frequency response:  hatG(omega) = begincases 1  hspace1cm -omega_c  omega  omega_c  0 hspace1cm mathrmotherwiseendcases\n\nThe Eulerian mean barf^mathrmE(vb*xt) is the field found by taking an average in time at a fixed spatial location vb*x. \n\nNote that OceananigansLagrangianFilter can also be used to find the Eulerian mean. Two different ways to do this are described in helpful tips.","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/#Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Lagrangian averaging","text":"In contrast, the Lagrangian mean finds the temporal average whilst moving with the flow on an (imaginary) fluid particle. We define the Lagrangian weighted temporal mean as \n\nbeginequation\nlabelfbardef\n    barf^mathrmL(barvb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation\n\nwhere the flow map  vb*varphi(vb*at) is the position at time t of a particle with label vb*a (which could be the initial position of the particle such that vb*varphi(vb*a0) = vb*a). The mean flow map barvb*varphi is defined by\n\nbeginequationlabelphibardef\nbarvb*varphi(vb*a t) = int_-infty^infty G(t-s)vb*varphi(vb*as)mathrmd s\nendequation\n\nThe definition \\eqref{fbardef} ensures that barf^mathrmL is the true generalised Lagrangian mean, in that (for strict band-pass filters) applying the same averaging procedure to the mean flow itself leaves it unchanged (Baker et al., 2025). However, we also define an alternative Lagrangian mean, which is a rearrangement of barf^mathrmL:\n\nbeginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation\n\nWhile barf^mathrmL(vb*xt) describes the average along a particle trajectory whose mean position is vb*x, f^*(vb*xt) defines the average along a particle trajectory whose position is vb*x at time t. It is often more desirable, or more convenient, to find f^* instead. If barf^mathrmL is also needed, it can be found by a rearrangement of f^* using a map\n\nbeginequation\n    vb*Xi(vb*varphi(vb*at)t) = barvb*varphi(vb*at)\nendequation","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Shallow-water-intertial-oscillations-with-offline-Lagrangian-filtering","page":"Shallow water inertial oscillation offline","title":"Shallow water intertial oscillations with offline Lagrangian filtering","text":"This example demonstrates how to perform offline filtering on a shallow water simulation to remove the effect of inertial oscillations on a tracer field.\n\nWe could also filter a shallow water simulation online, but would have to use the VectorInvariantFormulation in order to have direct access to the model velocities. This example uses the ConservativeFormulation instead, and filtering is performed offline using the saved velocities after they have been calculated from uh and vh.","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Run-the-simulation","page":"Shallow water inertial oscillation offline","title":"Run the simulation","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Install-dependencies","page":"Shallow water inertial oscillation offline","title":"Install dependencies","text":"using Oceananigans\nusing Printf\nusing NCDatasets\n\nfilename_stem = \"SW_IO_with_tracer\";","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Define-the-grid","page":"Shallow water inertial oscillation offline","title":"Define the grid","text":"grid = RectilinearGrid(CPU(), size = (50, 50),\n                       x = (0, 2*pi),\n                       y = (0, 2*pi),\n                       topology = (Periodic, Periodic, Flat))\n\n50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”x=0.125664\nâ”œâ”€â”€ Periodic y âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”y=0.125664\nâ””â”€â”€ Flat z                              ","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Set-parameters","page":"Shallow water inertial oscillation offline","title":"Set parameters","text":"Building a ShallowWaterModel. We non-dimensionalise as in Kafiabad & Vanneste 2023.\n\nFr = 0.1 # Froude number\nRo = 1 # fRossby number\n\ngravitational_acceleration = 1/Fr^2\ncoriolis = FPlane(f=1/Ro)\n\nFPlane{Float64}(f=1.0)","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Define-the-model","page":"Shallow water inertial oscillation offline","title":"Define the model","text":"model = ShallowWaterModel(grid; coriolis, gravitational_acceleration,\n                            timestepper = :RungeKutta3,\n                            tracers= (:T,),\n                            momentum_advection = WENO())\n\nShallowWaterModel{CPU, Float64}(time = 0 seconds, iteration = 0) \nâ”œâ”€â”€ grid: 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: \nâ”‚   â”œâ”€â”€ momentum: WENO{3, Float64, Float32}(order=5)\nâ”‚   â”œâ”€â”€ mass: WENO{3, Float64, Float32}(order=5)\nâ”‚   â””â”€â”€ T: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (:T,)\nâ””â”€â”€ coriolis: FPlane{Float64}","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Initial-conditions","page":"Shallow water inertial oscillation offline","title":"Initial conditions","text":"Velocity and height initial conditions - uniform velocity perturbation, initial height is 1 (unperturbed)\n\ndisplacement = 2*pi/10\nu_i = displacement/Ro\nh_i = 1\nuh_i = u_i*h_i;\n\nInitialise a tracer as a blob in the middle of the domain\n\nwidth = 2*pi/15\nT_i(x, y) = exp(-(((x - pi)^2 + (y - pi)^2)/width).^2)\n\nset!(model, uh = uh_i, h= h_i, T = T_i )\n\nuh, vh, h = model.solution\n\nu = Field(uh / h)\nv = Field(vh / h)\nT = model.tracers.T\n\n50Ã—50Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing\nâ””â”€â”€ data: 56Ã—56Ã—1 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, 1:1) with eltype Float64 with indices -2:53Ã—-2:53Ã—1:1\n    â””â”€â”€ max=0.999645, min=0.0, mean=0.0295409","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Simulation","page":"Shallow water inertial oscillation offline","title":"Simulation","text":"simulation = Simulation(model, Î”t = 1e-2, stop_time = 20)\n\nfunction progress(sim)\n    model = sim.model\n    uh, vh, h = model.solution\n    @info @sprintf(\"Simulation time: %s, max(|uh|, |vh|, |h|): %.2e, %.2e, %.2e \\n\",\n                   prettytime(sim.model.clock.time),\n                   maximum(abs, uh), maximum(abs, vh),\n                   maximum(abs, h))\n\n    return nothing\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))\n\nCallback of progress on IterationInterval(100)","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Set-up-the-outputs","page":"Shallow water inertial oscillation offline","title":"Set up the outputs","text":"Save velocities and tracer for Lagrangian filtering\n\nsimulation.output_writers[:fields_jld2] = JLD2Writer(model, (; u,v,T),\n                                                        filename = filename_stem * \".jld2\",\n                                                        schedule = TimeInterval(0.1),\n                                                        overwrite_existing = true)\n\nJLD2Writer scheduled on TimeInterval(100 ms):\nâ”œâ”€â”€ filepath: SW_IO_with_tracer.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, T)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 0 bytes (file not yet created)","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#And-finally-run-the-simulation.","page":"Shallow water inertial oscillation offline","title":"And finally run the simulation.","text":"run!(simulation)\n\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds, max(|uh|, |vh|, |h|): 6.28e-01, 0.00e+00, 1.00e+00 \n[ Info:     ... simulation initialization complete (5.995 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (7.976 seconds).\n[ Info: Simulation time: 990.000 ms, max(|uh|, |vh|, |h|): 3.45e-01, 5.25e-01, 1.00e+00 \n[ Info: Simulation time: 1.990 seconds, max(|uh|, |vh|, |h|): 2.56e-01, 5.74e-01, 1.00e+00 \n[ Info: Simulation time: 2.900 seconds, max(|uh|, |vh|, |h|): 6.10e-01, 1.50e-01, 1.00e+00 \n[ Info: Simulation time: 3.810 seconds, max(|uh|, |vh|, |h|): 4.93e-01, 3.89e-01, 1.00e+00 \n[ Info: Simulation time: 4.720 seconds, max(|uh|, |vh|, |h|): 4.78e-03, 6.28e-01, 1.00e+00 \n[ Info: Simulation time: 5.630 seconds, max(|uh|, |vh|, |h|): 4.99e-01, 3.82e-01, 1.00e+00 \n[ Info: Simulation time: 6.540 seconds, max(|uh|, |vh|, |h|): 6.08e-01, 1.60e-01, 1.00e+00 \n[ Info: Simulation time: 7.450 seconds, max(|uh|, |vh|, |h|): 2.47e-01, 5.78e-01, 1.00e+00 \n[ Info: Simulation time: 8.360 seconds, max(|uh|, |vh|, |h|): 3.05e-01, 5.50e-01, 1.00e+00 \n[ Info: Simulation time: 9.270 seconds, max(|uh|, |vh|, |h|): 6.21e-01, 9.69e-02, 1.00e+00 \n[ Info: Simulation time: 10.180 seconds, max(|uh|, |vh|, |h|): 4.57e-01, 4.31e-01, 1.00e+00 \n[ Info: Simulation time: 11.090 seconds, max(|uh|, |vh|, |h|): 5.92e-02, 6.26e-01, 1.00e+00 \n[ Info: Simulation time: 12.000 seconds, max(|uh|, |vh|, |h|): 5.30e-01, 3.37e-01, 1.00e+00 \n[ Info: Simulation time: 12.900 seconds, max(|uh|, |vh|, |h|): 5.94e-01, 2.06e-01, 1.00e+00 \n[ Info: Simulation time: 13.810 seconds, max(|uh|, |vh|, |h|): 2.02e-01, 5.95e-01, 1.00e+00 \n[ Info: Simulation time: 14.720 seconds, max(|uh|, |vh|, |h|): 3.46e-01, 5.25e-01, 1.00e+00 \n[ Info: Simulation time: 15.630 seconds, max(|uh|, |vh|, |h|): 6.26e-01, 4.89e-02, 1.00e+00 \n[ Info: Simulation time: 16.590 seconds, max(|uh|, |vh|, |h|): 3.99e-01, 4.85e-01, 1.00e+00 \n[ Info: Simulation time: 17.590 seconds, max(|uh|, |vh|, |h|): 1.92e-01, 5.98e-01, 1.00e+00 \n[ Info: Simulation time: 18.590 seconds, max(|uh|, |vh|, |h|): 6.07e-01, 1.61e-01, 1.00e+00 \n[ Info: Simulation time: 19.590 seconds, max(|uh|, |vh|, |h|): 4.64e-01, 4.24e-01, 1.00e+00 \n[ Info: Simulation is stopping after running for 1.892 minutes.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Perform-Lagrangian-filtering","page":"Shallow water inertial oscillation offline","title":"Perform Lagrangian filtering","text":"Now we set up and run the offline Lagrangian filter on the output of the above simulation. This could be performed in a different script (with appropriate import of Oceananigans.Units and CUDA if needed)\n\nusing OceananigansLagrangianFilter","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Set-up-the-filter-configuration","page":"Shallow water inertial oscillation offline","title":"Set up the filter configuration","text":"filter_config = OfflineFilterConfig(original_data_filename=\"SW_IO_with_tracer.jld2\", # Where the original simulation output is\n                                    output_filename = \"SW_IO_with_tracer_filtered.jld2\", # Where to save the filtered output\n                                    var_names_to_filter = (\"T\",), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for remapping\n                                    architecture = CPU(), # CPU() or GPU(), if GPU() make sure you have CUDA.jl installed and imported\n                                    Î”t = 1e-2, # Time step of filtering simulation\n                                    T_out=0.1, # How often to output filtered data\n                                    N=2, # Order of Butterworth filter\n                                    freq_c = 0.5, #Â Cut-off frequency of Butterworth filter\n                                    compute_mean_velocities= true, # Whether to compute mean velocities\n                                    output_netcdf = true, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\nOfflineFilterConfig(\"SW_IO_with_tracer.jld2\", (\"T\",), (\"u\", \"v\"), 0.0, 20.0, 20.0, CPU(), 0.1, (a1 = 0.17677669529663687, b1 = 0.1767766952966369, c1 = 0.35355339059327373, d1 = 0.3535533905932738, N_coeffs = 1), 0.01, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"SW_IO_with_tracer_filtered.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ”‚   â””â”€â”€ buffer_scheme: Centered(order=2)\nâ””â”€â”€ advecting_velocity_scheme: Centered(order=4), 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”x=0.125664\nâ”œâ”€â”€ Periodic y âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”y=0.125664\nâ””â”€â”€ Flat z                              , \"offline\", \"\")","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Run-the-offline-Lagrangian-filter","page":"Shallow water inertial oscillation offline","title":"Run the offline Lagrangian filter","text":"run_offline_Lagrangian_filter(filter_config)\n\n[ Info: Loaded data from SW_IO_with_tracer.jld2\n[ Info: Created original variables: (:T,)\n[ Info: Created filtered variables: (:T_C1, :xi_u_C1, :xi_v_C1, :T_S1, :xi_u_S1, :xi_v_S1)\n[ Info: Created forcing for filtered variables\n[ Info: Created model\n[ Info: Initialised filtered variables\n[ Info: Defined outputs\n[ Info: Defined simulation\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (2.484 minutes)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (13.118 seconds).\n[ Info: Simulation time: 2 seconds\n[ Info: Simulation time: 4 seconds\n[ Info: Simulation time: 6 seconds\n[ Info: Simulation time: 8 seconds\n[ Info: Simulation time: 10 seconds\n[ Info: Simulation time: 12 seconds\n[ Info: Simulation time: 14 seconds\n[ Info: Simulation time: 16 seconds\n[ Info: Simulation time: 18 seconds\n[ Info: Simulation is stopping after running for 8.012 minutes.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n[ Info: Simulation time: 20 seconds\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (67.987 ms)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (184.877 ms).\n[ Info: Simulation time: 2 seconds\n[ Info: Simulation time: 4 seconds\n[ Info: Simulation time: 6 seconds\n[ Info: Simulation time: 8 seconds\n[ Info: Simulation time: 10 seconds\n[ Info: Simulation time: 12 seconds\n[ Info: Simulation time: 14 seconds\n[ Info: Simulation time: 16 seconds\n[ Info: Simulation time: 18 seconds\n[ Info: Simulation is stopping after running for 4.875 minutes.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n[ Info: Simulation time: 20 seconds\n[ Info: Combined forward and backward contributions into SW_IO_with_tracer_filtered.jld2\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file SW_IO_with_tracer_filtered.jld2\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable v\n[ Info: Wrote NetCDF file to SW_IO_with_tracer_filtered.nc\n","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Visualisation","page":"Shallow water inertial oscillation offline","title":"Visualisation","text":"using CairoMakie\n\nNow we animate the results.\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               limits = ((0, 2*pi), (0, 2*pi)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer T at time = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"IO_filtered_tracer_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend\n\n\"IO_filtered_tracer_movie_offline.mp4\"\n\n(Image: )\n\nWe see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures.\n\n#Â We remove these files to keep things tidy, keep them for analysis if desired\nrm(filename_stem * \".jld2\")\nrm(filter_config.output_filename)\nrm(filter_config.output_filename[1:end-5] * \".nc\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"offline_filtering/offline_how_it_works/#How-it-works","page":"How it works","title":"How it works","text":"The offline Lagrangian filter uses many of the same helper functions as the online filter, but since the calculation doesn't need to be integrated into the user simulation, the steps are hidden and performed within the function run_offline_Lagrangian_filter. These steps can be seen in the source code. \n\nAlternatively, the computation can be customised by directly using the helper functions rather than running run_offline_Lagrangian_filter. ","category":"section"},{"location":"helpful_tips/#Helpful-tips","page":"Helpful tips","title":"Helpful tips","text":"The online and offline filtering both work on GPU, just make sure CUDA is installed in the environment and loaded, and set architecture = GPU()\nThe post-processing interpolation step using regrid_to_mean_position! isn't currently set up to work in domains with immersed boundaries, with more than one bounded dimension, or on non-rectlinear grids. \nAs with any moving average, there are endpoint effects. For the offline filter, a time window at each end of the filtered timeseries of the order of the inverse of the cutoff frequency should be excluded from any further analysis. For the online filter, this is only necessary at the beginning of the timeseries. \nThis method is not tested with open boundaries. There is a fundamental causal issue with knowing the Lagrangian mean near a boundary when part of the trajectory on which it relies is outside of the domain. There are ways to approximate the solution near the open boundary to allow the code to run, (e.g. setting an open boundary condition on the Lagrangian filtered variables) but then the near-boundary region should be discarded. \nThis package can be used to filter output from other numerical models (offline). In particular, model output that shares the same Arakawa type-C grid (such as MITgcm) can easily be manipulated into Oceananigans output format and run through the Lagrangian filter. \nEulerian filtering can be performed in two ways. The first (naive) way is to set compute_Eulerian_filter = true in the configuration for the offline filter, or use compute_Eulerian_filter! in the online filter. This will use the filter output file (and therefore data output at your filter output frequency rather than the original data frequency) to loop over that data and compute the Eulerian mean at each timestep. For small datasets with high output frequency (see examples) this is suitable. The second way is only possible for the offline filter, and is analogous to how the Lagrangian filter is computed. This is better for large datasets. Run the offline filter as you would for the Lagrangian filter, but set advection = nothing in the OfflineFilterConfig, and the Eulerian mean will be computed instead. Note that the maps are now meaningless, so map_to_mean should be false and no regridding performed at the end. ","category":"section"},{"location":"#OceananigansLagrangianFilter.jl","page":"Home","title":"OceananigansLagrangianFilter.jl","text":"A package to compute Lagrangian temporal filters of Oceananigans.jl simulation output\n\nThis package builds on and is intended to be used with Oceananigans.jl (Wagner et al., 2025).\n\nThe Lagrangian filter can be run in two ways\n\nOnline: integrated into your Oceananigans simulation. This avoids the need to save data at wave-resolving resolution, but the available filter shapes are more limited. \nOffline: run after your Oceananigans simulation (or, feasibly, on any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the fields to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. \n\n(Image: )","category":"section"}]
}
