var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Baker,¬†L.¬†E.; Kafiabad,¬†H.¬†A.; Maitland-Davies,¬†C. and Vanneste,¬†J. (2025). Lagrangian Filtering for Wave‚ÄìMean Flow Decomposition. Journal¬†of¬†Fluid¬†Mechanics 1009, A40.\n\n\n\nKafiabad,¬†H.¬†A. and Vanneste,¬†J. (2023). Computing Lagrangian Means. Journal¬†of¬†Fluid¬†Mechanics 960, A36.\n\n\n\nMinz,¬†A.; Baker,¬†L.¬†E.; Kafiabad,¬†H.¬†A. and Vanneste,¬†J. (2025). Efficient Lagrangian Averaging with Exponential Filters. Phys.¬†Rev.¬†Fluids 10, 074902.\n\n\n\n","category":"page"},{"location":"offline_filtering/offline_implementation/#Offline-filtering-implementation","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"","category":"section"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"The offline Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved after the original Oceananigans simulation (or, feasibly, using any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the tracer(s) f to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. ","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"The offline filter uses mostly the same functions as the online filter to define filtered fields and their forcings, but in this case most of the process is 'under the hood', as the user only needs to provide the simulation data and specify the configuration. An example is given in offlinefiltergeostrophic_adjustment.jl, and more detail on how it works is given in How it works.","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"A short example of how to implement offline filtering on a GPU is given below:","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"using OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Œît = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #¬†Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"üõ†Ô∏è Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For now, you can install the package from github. With a fresh or existing julia environment activated, either  access the Pkg REPL and use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or in julia:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git\")\n","category":"page"},{"location":"online_filtering/choosing_online_filters/#Choosing-online-filters","page":"Choosing online filters","title":"Choosing online filters","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"To be added. ","category":"page"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"TLDR; set N and freq_c in OnlineFilterConfig to get a Butterworth filter of order N with cutoff frequency freq_c.","category":"page"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"If N=1 then an exponential filter is found. Otherwise, N should be even. ","category":"page"},{"location":"online_filtering/choosing_online_filters/#General-form","page":"Choosing online filters","title":"General form","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Exponential","page":"Choosing online filters","title":"Exponential","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Butterworth","page":"Choosing online filters","title":"Butterworth","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Define-your-own","page":"Choosing online filters","title":"Define your own","text":"","category":"section"},{"location":"online_filtering/online_implementation/#Online-filtering-implementation","page":"Online filtering implementation","title":"Online filtering implementation","text":"","category":"section"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"The online Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved at the same time as the governing equations of your simulation, in which the original tracer f is being found. Filtered velocities can also be found. This means that equations for the filtered tracers, and optionally the maps (see Online Lagrangian filtering equations) need to be passed to your model. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"OceananigansLagrangianFilter provides helper functions to define these extra fields and their forcings, and an example is given in onlinefiltergeostrophic_adjustment.jl. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Other helper functions are provided to initialise the filtered variables, define output fields that compute f^*, regrid f^* to barf^mathrmL (see Lagrangian averaging), compute the Eulerian filter for comparison, compute a shifted time variable, and output a final NetCDF file. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"We summarise here the protocol for implementing online Lagrangian filtering","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Install OceananigansLagrangianFilter in your environment (see Quick Start).\nLoad OceananigansLagrangianFilter and its utility functions at the top of your script. This automatically loads Oceananigans.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"using OceananigansLagrangianFilter\nusing OceananigansLagrangianFilter.Utils","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Setup your parameters, grid, tracers, and forcing as normal\nDefine your filter_config - an OnlineFilterConfig. This takes as arguments:\ngrid: the grid you have already defined\noutput_filename: a filename to save filtered output to\nvar_names_to_filter: a tuple of strings defining the names of variables to filter. These can be any of your tracers. Velocities to filter don't need to be listed here (see below).\nvelocity_names: the velocity names that you want to use to compute Lagrangian trajectories. These are also the velocities that will be filtered if compute_mean_velocities = true.\nN and freq_c: Can be provided together to give a Butterworth filter of order N with cutoff frequency freq_c. \nfilter_params: a named tuple of coefficients a1, b1, c1, d1, a2, b2, c2, d2, etc defining a filter kernel (see Choosing online filters).\nmap_to_mean: A Bool determining whether to compute the maps vb*xi_Ck and vb*xi_Sk and solve their equations (see Online Lagrangian filtering equations).\ncompute_mean_velocities: A Bool determining whether to compute and output the mean velocities. They are computed from the maps vb*xi_Ck and vb*xi_Sk, so if map_to_mean=false and compute_mean_velocities=true the maps will still be computed. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = filename_stem * \".jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = f/2)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Create the filtered variables g_Ck, g_Sk, vb*xi_Ck and vb*xi_Sk using the function create_filtered_vars, which only needs the filter_config. These filtered variables will be added to the model as tracers.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filtered_vars = create_filtered_vars(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Create forcing for these filtered variables using the function create_forcing. This implements the right-hand-sides of the tracer and map equations (see Online Lagrangian filtering equations). Merge this filter_forcing with your existing forcing. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filter_forcing = create_forcing(filtered_vars, filter_config)\nforcing = merge(forcing, filter_forcing);","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"If you're using a closure, you'll need to tell the filtered scalars not to use a closure (although they could be given a closure if necessary for stability - this has proved unecessary so far and is more accurate). A helper function zero_closure_for_filtered_vars to set the diffusivity to zero for each of the filtered variables is provided.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"zero_filtered_var_closure = zero_closure_for_filtered_vars(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the closure for your model variables using the zero_filtered_var_closure","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"horizontal_closure = HorizontalScalarDiffusivity(ŒΩ=1e-6, Œ∫=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nvertical_closure = VerticalScalarDiffusivity(ŒΩ=1e-6 , Œ∫=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nclosure = (horizontal_closure, vertical_closure)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the model with the combined (original and filtered) tracers, forcing and closure. This should work with both NonHydrostaticModel and HydrostaticFreeSurfaceModel.\nInitialise your model variables as normal\nInitialise the filtered variables (this uses the previously initialised model variables to give a better initialisation, so needs to be performed after the previous step)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"initialise_filtered_vars_from_model(model, filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the simulation, any callbacks, conjure_time_step_wizard, etc as normal\nUse the create_output_fields helper function to define the output fields (this defines the outputs f^* and vb*Xi so that all of the intermediate filter variables are not output by default, though they could be examined as for any other tracer)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"outputs = create_output_fields(model, filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Add in any other output fields, including the original fields if desired (not included by default in the online filter).","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"outputs[\"b\"] = model.tracers.b\noutputs[\"T\"] = model.tracers.T\noutputs[\"u\"] = model.velocities.u\noutputs[\"v\"] = model.velocities.v\noutputs[\"w\"] = model.velocities.w","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define a JLD2Writer for the outputs. The filename should be the same as filter_config.output_filename. For the post-processing functions provided in the next few steps, this does need to be a JLD2Writer rather than a NetCDFWriter, but a helper function is provided to output a final .nc file if needed. \nRun the simulation","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"run!(simulation)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally regrid to mean position using regrid_to_mean_position!. This adds a new field to the output data file.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"if filter_config.map_to_mean\n    regrid_to_mean_position!(filter_config)\nend","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally compute the Eulerian filter (with the same filter_params) using compute_Eulerian_filter!.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"compute_Eulerian_filter!(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally compute a shifted time coordinate to give a more appropriate reference time for the average. The new reference time is calculated as the weighted mean of time: t_shift = int_-infty^t G(t-s)s mathrmd s","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"compute_time_shift!(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally output a final NetCDF file using jld2_to_netcdf. This helper function should work for any .jld2 Oceananigans output. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"jld2_to_netcdf(filename_stem * \".jld2\", filename_stem * \".nc\")","category":"page"},{"location":"library/#OceananigansLagrangianFilter.jl-Library","page":"Library","title":"OceananigansLagrangianFilter.jl Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(;\n\n)\n\nA configuration object for online filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(; grid::AbstractGrid,\n                        output_filename::String = \"online_filtered_output\",\n                        var_names_to_filter::Tuple{Vararg{String}},\n                        velocity_names::Tuple{Vararg{String}},\n                        N::Union{Int, Nothing} = nothing,\n                        freq_c::Union{Int, Nothing} = nothing,\n                        filter_params::Union{NamedTuple, Nothing} = nothing,\n                        map_to_mean::Bool = true,\n                        compute_mean_velocities::Bool = true,\n                        npad::Int = 5,\n                        filter_mode::String = \"online\"\n                        )\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\ngrid: (required) The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\noutput_filename: The filename for the output of the online filtered data. Default: \"online_filtered_output\".\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nN, freq_c: Parameters for a Butterworth filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"online\". TODO use multiple dispatch for this instead.\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\n\nNx = 50\nNz = 20\nL = 10kilometers \nH = 100meters \n\ngrid = RectilinearGrid(CPU(),size = (Nx, Nz), \n                       x = (-L/2, L/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))\n\nfilter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = \"test_filter.jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = 1e-4/2)\n\n# output\n\n[ Info: Setting filter parameters to use Butterworth order 2, cutoff frequency 5.0e-5\nOnlineFilterConfig(50√ó1√ó20 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo\n‚îú‚îÄ‚îÄ Periodic x ‚àà [-5000.0, 5000.0) regularly spaced with Œîx=200.0\n‚îú‚îÄ‚îÄ Flat y                         \n‚îî‚îÄ‚îÄ Bounded  z ‚àà [-100.0, 0.0]     regularly spaced with Œîz=5.0, \"test_filter.jld2\", (\"b\", \"T\"), (\"u\", \"w\"), (a1 = 1.421067568548072e-20, b1 = -7.071067811865475e-5, c1 = 3.535533905932738e-5, d1 = -3.535533905932738e-5, N_coeffs = 1), true, true, 5, \"online\")\n\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(;\n    \n)\n\nA configuration object for apply_offline_filter.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(; original_data_filename::String,\n                    var_names_to_filter::Tuple{Vararg{String}},\n                    velocity_names::Tuple{Vararg{String}},\n                    T_start::Union{Real,Nothing} = nothing,\n                    T_end::Union{Real,Nothing} = nothing,\n                    T::Union{Real,Nothing} = nothing,\n                    architecture::AbstractArchitecture = CPU(),\n                    T_out::Union{Real,Nothing} = nothing,\n                    N::Union{Int, Nothing} = nothing,\n                    freq_c::Union{Int, Nothing} = nothing,\n                    filter_params::Union{NamedTuple, Nothing} = nothing,\n                    Œît::Union{Real,Nothing} = nothing,\n                    backend::AbstractInMemoryBackend = InMemory(4),\n                    map_to_mean::Bool = true,\n                    forward_output_filename::String = \"forward_output.jld2\",\n                    backward_output_filename::String = \"backward_output.jld2\",\n                    output_filename::String = \"filtered_output.jld2\",\n                    npad::Int = 5,\n                    compute_mean_velocities::Bool = true,\n                    delete_intermediate_files::Bool = true,\n                    compute_Eulerian_filter::Bool = false,\n                    output_netcdf::Bool = false,\n                    output_original_data::Bool = true\n                    advection::AbstractAdvectionScheme = WENO(),\n                    grid::Union{AbstractGrid, Nothing} = nothing,\n                    filter_mode::String = \"offline\")\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\noriginal_data_filename: (required) The path to the JLD2 file containing the original Oceananigans output data.\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nT_start: Start time for the filter. Must be within the time range of the data. If not given, defaults to either T_end - T (if they are given), or the start time of the original data.\nT_end: End time for the filter. Must be within the time range of the data. If not given, defaults to either Tstart + T (after Tstart given or computed, if T is given), or the end time of the original data.\nT: Duration of the filtering. If not given, defaults to Tend - Tstart (after Tstart and Tend are given or computed).\narchitecture: The architecture (CPU or GPU) to be used for the filtering computation. Default: CPU().\nT_out: The output time step for the filtered data. If nothing, it defaults to the time step of the original data.\nN, freq_c: Parameters for a Butterworth squared filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nŒît: The time step for the internal Lagrangian filter simulation. If nothing, it defaults to T_out / 10, but this may not be appropriate.\nbackend: The backend for loading FieldTimeSeries data. See Oceananigans.Fields.FieldTimeSeries. Default: InMemory(4).\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\nforward_output_filename: The filename for the output of the forward filter pass. Default: \"forward_output.jld2\".\nbackward_output_filename: The filename for the output of the backward filter pass. Default: \"backward_output.jld2\".\noutput_filename: The filename for the final combined and mapped output. Default: \"filtered_output.jld2\".\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\ndelete_intermediate_files: A Bool indicating whether to delete forward_output.jld2 and backward_output.jld2 after the final combined file is created. Default: true.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\noutput_netcdf: A Bool indicating whether to also convert the final JLD2 output file to a NetCDF file. Default: false.\noutput_original_data: A Bool indicating whether to include the original data in the final output file for comparison. Default: true.\nadvection: The advection scheme to use for the Lagrangian filter simulation. Default: WENO(). Using lower-order schemes may be a source of error.\ngrid: The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"offline\". TODO use multiple dispatch for this instead.\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\npath_to_sim = \"../test/data/reference_sim.jld2\"\nfilter_config = OfflineFilterConfig(original_data_filename=path_to_sim, \n                                    output_filename = \"output_file.jld2\", \n                                    var_names_to_filter = (\"b\",), \n                                    velocity_names = (\"u\",\"w\"), \n                                    architecture = CPU(), \n                                    Œît = 20minutes, \n                                    T_out = 1hour, \n                                    N = 2, \n                                    freq_c = 1e-4/2, \n                                    compute_mean_velocities = true, \n                                    output_netcdf = true, \n                                    delete_intermediate_files = true, \n                                    compute_Eulerian_filter = true) \n\n# output\n\n[ Info: Filter interval will be from T_start=0.0 to T_end=86400.0, duration T=86400.0\n[ Info: Setting filter parameters to use Butterworth squared, order 2, cutoff frequency 5.0e-5\nOfflineFilterConfig(\"../test/data/reference_sim.jld2\", (\"b\",), (\"u\", \"w\"), 0.0, 86400.0, 86400.0, CPU(), 3600.0, (a1 = 1.767766952966369e-5, b1 = 1.767766952966369e-5, c1 = 3.535533905932738e-5, d1 = 3.535533905932738e-5, N_coeffs = 1), 1200.0, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"output_file.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\n‚îú‚îÄ‚îÄ buffer_scheme: WENO{2, Float64, Float32}(order=3)\n‚îî‚îÄ‚îÄ advection_velocity_scheme: Centered(order=4), 10√ó1√ó10 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo\n‚îú‚îÄ‚îÄ Periodic x ‚àà [-5000.0, 5000.0) regularly spaced with Œîx=1000.0\n‚îú‚îÄ‚îÄ Flat y                         \n‚îî‚îÄ‚îÄ Bounded  z ‚àà [-100.0, 0.0]     regularly spaced with Œîz=10.0, \"offline\")\n\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter-Tuple{Any}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter","text":"run_offline_Lagrangian_filter(config::OfflineFilterConfig)\n\nRuns an offline Lagrangian filter on an Oceananigans FieldTimeSeries dataset as configured by config.\n\nThis function performs a series of steps to filter the data:\n\nPrepare data on disk: The input data is copied and manipulated on disk to be suitable for the forward and backward Lagrangian simulations.\nRun forward simulation: A LagrangianFilter model is created and run forward in time to compute the first half of the filter contributions.\nRun backward simulation: The input data is re-prepared for a backward pass, and the simulation is run a second time to compute the remaining contributions.\nCombine results: The forward and backward simulation outputs are summed to produce the final filtered data.\nPost-processing: Optional post-processing steps are performed, including regridding the data to the mean position, computing a comparative Eulerian filter, and converting the output file to NetCDF.\nCleanup: Intermediate files are removed to save disk space.\n\nArguments\n\nconfig: An instance of OfflineFilterConfig that specifies all parameters and file paths for the filtering process.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils","page":"Library","title":"OceananigansLagrangianFilter.Utils","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!","text":"compute_Eulerian_filter!(config::AbstractConfig)\n\nComputes the Eulerian filter for specified variables and writes the results to a combined output file. This function performs a direct, convolution-style filtering of a time series by applying a weighting function to the data at each time step.\n\nThe function iterates through each variable to be filtered:\n\nReads data: The entire time series of the variable is read from the  JLD2 file.\nApplies weighting: At each output time, a weighting function G is  computed and applied to the entire time series. The weighted data is summed  to produce the filtered field.\nWrites output: The resulting filtered field is saved back to the  same JLD2 file in a new group with the _Eulerian_filtered suffix.\n\nThis method serves as a benchmark for comparison with the main Lagrangian filter.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, and filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_time_shift!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_time_shift!","text":"compute_time_shift!(config::AbstractConfig)\n\nComputes the time shift for an online filter based on its coefficients and writes the shifted time series to the output file.\n\nThis function is only applicable for online filtering. The time shift is computed as the time delay introduced by the filter's transfer function. This new time series is stored in a new group called timeseries/t_shifted within the output JLD2 file.\n\nArguments\n\nconfig: A configuration object of type OfflineFilterConfig which contains the filter_mode, output_filename, and filter_params (filter coefficients).\n\nThrows\n\nerror: If config.filter_mode is not \"online\". The time shift for offline (forward-backward) filtering is zero by definition due to an even weight function.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_filtered_vars","text":"create_filtered_vars(config::AbstractConfig)\n\nCreates a Tuple of Symbols representing the names of the filtered tracer variables.\n\nFor a single-exponential filter (N_coeffs = 0.5), the function generates names with a _C1 suffix.\nFor a multi-coefficient filter (N_coeffs > 0.5), it generates pairs of names for each coefficient, suffixed with _C# and _S#, where # is the coefficient index.\n\nIf map_to_mean or compute_mean_velocities is enabled in the configuration, additional symbols are created for the spatial mapping variables corresponding to each velocity component, prefixed with xi_ and suffixed with the corresponding coefficient names.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables to filter, the filter parameters, and the map_to_mean and compute_mean_velocities booleans.\n\nReturns\n\nA Tuple of Symbols representing the names of the filtered variables to be used as tracers in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_forcing-Tuple{Tuple{Vararg{Symbol}}, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_forcing","text":"create_forcing(filtered_vars::Tuple{Vararg{Symbol}}, config::AbstractConfig)\n\nCreates a NamedTuple of forcing functions for each filtered variable and, if enabled, for the spatial mapping variables. These forcing terms are used to numerically integrate the filter equations.\n\nThe function handles two cases: a single-exponential filter (N_coeffs = 0.5) and a multi-coefficient Butterworth squared filter (N_coeffs > 0.5).\n\nFor standard filtered variables, the forcing is a combination of terms derived from the filter's coefficients and a term from the original data.\nFor spatial mapping variables (if map_to_mean or compute_mean_velocities is true), the forcing includes terms derived from the filter's coefficients and a term from the original velocity data.\n\nArguments\n\nfiltered_vars: A Tuple of Symbols representing the names of the filtered variables.\nconfig: An instance of AbstractConfig containing the names of the variables to be filtered, velocity names, and the filter parameters.\n\nReturns\n\nA NamedTuple where each key is a variable name from filtered_vars and each value is a Tuple of the corresponding forcing functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_input_data_on_disk-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_input_data_on_disk","text":"create_input_data_on_disk(config::AbstractConfig; direction::String=\"forward\")\n\nPrepares a new JLD2 file on disk with the time-filtered data for a forward or backward Lagrangian simulation.\n\nThis function performs the following steps:\n\nValidates direction: Ensures the direction is either \"forward\"  or \"backward\".\nCreates a new file: A new JLD2 file is created with the suffix  _filter_input.jld2 and any existing file with the same name is deleted.\nCopies metadata: Key metadata from the original file (e.g., grid  information) is copied to the new file to maintain consistency.\nTime truncation: The data is truncated to the time range specified by  config.T_start and config.T_end.\nTime shifting:\nFor \"forward\" filtering, a new time variable is created, shifted so   that t=0 corresponds to config.T_start.\nFor \"backward\" filtering, the data is re-ordered and a new time   variable is created, shifted so that t=0 corresponds to config.T_end.\nVelocity reversal: For \"backward\" filtering, the velocity fields  (u, v, w) are negated to correctly simulate backward advection.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and time specifications.\n\nKeyword Arguments\n\ndirection: A String indicating the simulation direction. It must be either \"forward\" (the default) or \"backward\".\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_original_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_original_vars","text":"create_original_vars(config::AbstractConfig)\n\nCreates a NamedTuple of CenterFields to serve as auxiliary fields for the original variables in a simulation. The fields are instantiated on the grid specified in the config object.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables and the simulation grid.\n\nReturns\n\nA NamedTuple where each key is a Symbol of a variable name to be filtered, and each value is an empty CenterField for that variable.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_output_fields-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_output_fields","text":"create_output_fields(model::AbstractModel, config::AbstractConfig)\n\nReconstructs the final output fields from the model's tracers and auxiliary fields. This function performs the following steps:\n\nReconstructs filtered variables: For each variable to be filtered, it sums  the contributions from the individual filter coefficients (_C and _S  tracers) using the coefficients from filter_params.\nReconstructs spatial mapping fields: If spatial mapping is enabled,  the function also reconstructs the xi_ fields that represent the filtered  position.\nBuilds mean velocities: If compute_mean_velocities is true, the function  reconstructs the mean velocity fields using the xi_ fields.\nIncludes original data: The original data is added to the output  dictionary for comparison and analysis if config.output_original_data  is true.\n\nArguments\n\nmodel: An instance of an AbstractModel containing the tracer and auxiliary fields.\nconfig: An instance of AbstractConfig with the names of the variables, velocity components, and filter parameters.\n\nReturns\n\nA Dict where keys are the names of the output fields (e.g., var_name_Lagrangian_filtered, xi_vel_name, var_name) and values are the corresponding reconstructed Fields.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_frequency_response-Tuple{AbstractArray, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_frequency_response","text":"get_frequency_response(freq::AbstractArray, filter_params::NamedTuple)\n\nCalculates the frequency response of the offline filter. This function takes a set of frequencies and the filter's coefficients to compute how the filter amplifies or attenuates different frequency components of a signal.\n\nThe response is computed by summing the contributions of each coefficient pair based on the filter's transfer function in the frequency domain. The result is a measure of the filter's gain at each given frequency.\n\nArguments\n\nfreq: A vector of frequencies (in radians per unit time).\nfilter_params: A NamedTuple containing the filter coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\n\nReturns\n\nA vector Ghat representing the filter's frequency response at each corresponding frequency in freq.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_weight_function-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_weight_function","text":"get_weight_function(;t::AbstractArray, tref::Real, filter_params::NamedTuple, direction::String = \"both\")\n\nComputes the weighting function for the offline filter. This function calculates the filter's impulse response, which determines how much each point in the timeseries t contributes to the filtered value at a reference time tref. The weighting function is based on the provided filter_params, which contains the coefficients for the filter's impulse response.\n\nKeyword arguments\n\nt: A collection of time points in the timeseries.\ntref: The reference time at which the filter is being evaluated.\nfilter_params: A NamedTuple containing the coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\ndirection: A String indicating the direction of the filter. It can be \"both\" (default), \"forward\", or \"backward\". This determines whether the filter is applied symmetrically around tref, only to past times, or only to future times.\n\nReturns\n\nA vector of weights G, with the same dimensions as t, representing the value of the filter's impulse response at each time point relative to tref.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data-Tuple{Oceananigans.AbstractModel, NamedTuple, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data","text":"initialise_filtered_vars_from_data(model::AbstractModel, saved_original_vars::Tuple,\n                         config::AbstractConfig)\n\nInitializes the model's tracer fields, which represent the components of the filtered variables. This function sets the initial values of the filtered variables to the (scaled) first timestep of the original data. This improves the \"spin-up\" of the filter simulation by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nsaved_original_vars: A Tuple of FieldTimeSeries objects containing the original data for each variable.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model","text":"initialise_filtered_vars_from_model(model::AbstractModel,config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.jld2_to_netcdf-Tuple{String, String}","page":"Library","title":"OceananigansLagrangianFilter.Utils.jld2_to_netcdf","text":"jld2_to_netcdf(jld2_filename::String, nc_filename::String)\n\nConverts a JLD2 output file generated by an Oceananigans simulation into a standard NetCDF file. This function is useful for post-processing and for sharing data with other tools that expect the NetCDF format.\n\nThe conversion process involves the following steps:\n\nRead JLD2 data: Opens the input JLD2 file and reads the grid, time,  and all timeseries variables.\nCreate NetCDF file: Creates a new NetCDF file with a .nc extension.\nDefine dimensions: Defines NetCDF dimensions based on the grid sizes  and staggered locations (e.g., x_caa for cell centers, x_faa for  cell faces).\nDefine grid variables: Writes the grid coordinates and metadata  (e.g., Lx, Ny, Hx) as variables to the NetCDF file.\nWrite timeseries data: Iterates through each variable in the JLD2  file's timeseries, determines its location on the grid, and writes the  data to a new variable in the NetCDF file.\nAdd metadata: Adds attributes to each variable, including boundary  conditions and units, for better documentation.\n\nArguments\n\njld2_filename: A String specifying the path to the input JLD2 file.\nnc_filename: A String specifying the path for the output NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.load_data-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.load_data","text":"load_data(config::AbstractConfig)\n\nLoads the velocity and tracer data from the intermediate input file created by create_input_data_on_disk. The data for each variable is loaded as a FieldTimeSeries and returned as a single NamedTuple.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, \n\narchitecture, and backend.\n\nReturns\n\nA NamedTuple with fields velocity_data and var_data, where each field contains a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.regrid_to_mean_position!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.regrid_to_mean_position!","text":"regrid_to_mean_position!(config::AbstractConfig)\n\nRegrids the filtered data to the mean position. This function reads the combined  output file, interpolates the filtered variables to the mean position, and saves the result in new variables within the same file.\n\nThe regridding process involves the following steps:\n\nExtracts positions: The mean positions (xi_u, xi_v, xi_w) and  filtered variable data are extracted for each time step.\nHandles periodicity: For periodic dimensions (x, y, or z), the data is  padded by repeating values near the boundaries to ensure accurate  interpolation across the periodic boundaries.\nInterpolates data: A linear interpolator is used to map the filtered data  from the irregular advected positions to the original, regular grid points.\nSaves new fields: The regridded data is saved as new variables in the  combined output file, with a _Lagrangian_filtered_at_mean suffix.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and grid information.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params","text":"set_offline_BW2_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c, squared. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: Ghat(omega) = 1 / (1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*abs(t))*(a_i*cos(d_i * abs(t)) + b_i*sin(d_i * abs(t)))\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth squared filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_online_BW_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_online_BW_filter_params","text":"set_online_BW_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c. Note that the frequency response is not squared, like in the offline forward-backward filter, and the frequency response is not real-valued, implying a nonlinear phase shift. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: abs(Ghat(omega)) = 1 / sqrt(1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*t)* (a_i*cos(d_i * t) + b_i*sin(d_i * t))  for t>=0, and 0 for t<0.\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!","text":"sum_forward_backward_contributions!(config::AbstractConfig)\n\nCombines the output from the forward and backward filter simulations into a single output file. This function performs the final step of the offline filter algorithm by summing the contributions from each pass.\n\nThe function performs the following steps:\n\nInitializes the combined file: A new JLD2 file is created to store  the final output.\nCopies metadata and unfiltered data: The file structure, metadata,  and the original, unfiltered data are copied from the forward output file.\nSums filtered contributions: For each filtered variable, the data  from the backward output file is loaded as a FieldTimeSeries. The data  is then interpolated to match the time steps of the forward simulation,  and the two datasets are summed and written to the combined output file.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths and variable names.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.update_input_data!-Tuple{Simulation, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.update_input_data!","text":"update_input_data!(sim::Simulation, input_data::NamedTuple)\n\nUpdates the velocity and auxiliary fields of a simulation at the current simulation time t. This function is designed to be used as a callback in an Oceananigans Simulation.\n\nThe function performs two main tasks:\n\nUpdates velocities: It sets the u, v, and w velocity fields of  the model to the corresponding data from the velocity_data  FieldTimeSeries at the current simulation time.\nUpdates auxiliary fields: It updates the auxiliary fields of the  model with the original data from the var_data FieldTimeSeries, which  are used for forcing terms.\n\nArguments\n\nsim: The Simulation object.\ninput_data: A NamedTuple containing velocity_data and var_data, where each field is a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars","text":"zero_closure_for_filtered_vars(config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/#Quick-Start","page":"Quick start","title":"üöÄ Quick Start","text":"","category":"section"},{"location":"quick_start/#Offline-Filtering","page":"Quick start","title":"Offline Filtering","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Offline filtering (whereby the data is processed after simulation time) allows for better filter shapes, since for a given reference time, data from the past and the future is available. The filters implemented here have real frequency response, and therefore have linear phase shift. If the exact properties of the filter shape are important, then offline filtering is preferable. ","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Here is a simple example of how to filter a pre-existing dataset.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Œît = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #¬†Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can find an example of a simple simulation of geostrophic adjustment followed by offline filtering in offline_filter_geostrophic_adjustment.jl.","category":"page"},{"location":"quick_start/#Online-Filtering","page":"Quick start","title":"Online Filtering","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For online filtering, you would integrate the filter directly into your Oceananigans.jl setup, using the helper functions provided. This is explained full in Online filtering implementation, and an example is given in online_filtering_geostrophic_adjustment.jl. The filtered values are then computed as your simulation runs, avoiding the need to save data at high frequency. ","category":"page"},{"location":"theory/offline_equations/#Offline-Lagrangian-filtering-equations","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"","category":"section"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'offline' configuration of OceananigansLagrangianFilter.jl. The offline scheme runs a forward pass very similar to the online configuration, before running a backward pass through the offline data and combinging the backward and forward outputs. ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We compute the Lagrangian mean of some scalar f as","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and optionally compute","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^infty alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We consider even filter kernels composed of sums of exponentials of the absolute value of t:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\n    G(t) = sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We define a set of N weight functions, for even N. For k = 1N2 we have","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    G_Ck(t) =e^-c_ktcos d_k t \n    G_Sk(t) =e^-c_ktsin d_k t \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"For t0, we have","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and for t0","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign labelbackward_G_derivs\n    G_Ck(t) = -G_Ck(-t) = c_kG_Ck(t) + d_k G_Sk(t) \n    G_Sk(t) = -G_Sk(-t) = c_kG_Sk(t) - d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We then define a corresponding set of N filtered scalars","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\n    f_1^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk \nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"This system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0.","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"If we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"To define perturbation equations, we set:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"where the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk \nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"Backward-pass equations of the same form are solved by time-reversing the velocity and field data, and changing the sign of the velocity. The final filtered field is then reconstructed by summing the forwards and backwards pass outputs at each time. ","category":"page"},{"location":"technical_comments/#Technical-comments","page":"Technical comments","title":"Technical comments","text":"","category":"section"},{"location":"technical_comments/","page":"Technical comments","title":"Technical comments","text":"The online and offline filtering both work on GPU, just make sure CUDA is installed in the environment and loaded, and set architecture = GPU()\nThe post-processing interpolation step using regrid_to_mean_position! isn't currently set up to work in domains with immersed boundaries or with more than one bounded dimension. Interpolation results might be junk near the boundary!\nFor the offline filter, saved tracers to be filtered need to be on Center grid. Velocities should be on their standard grid. \nAs with any moving average, there are endpoint effects. For the offline filter, a time window at each end of the filtered timeseries of the order of the inverse of the cutoff frequency should be excluded from any further analysis. For the online filter, this is only necessary at the beginning of the timeseries. ","category":"page"},{"location":"theory/online_equations/#Online-Lagrangian-filtering-equations","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"","category":"section"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'online' configuration of OceananigansLagrangianFilter.jl. They are very similar to the forward pass of the offline configuration.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We directly compute the Lagrangian mean of some scalar f as","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^t G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and optionally compute","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We consider filter kernels composed of sums of N exponentials, where N is even.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelonlinekernel\n    G(t) = begincases\n    sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right) hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We require G to be normalised such that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\n    int_-infty^infty G(s)  ds = 1\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"or equivalently, that hatG(0) = 1. This requires that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\n    sum_n=1^N2 fraca_nc_n + b_n d_nc_n^2 + d_n^2 = 1\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This normalisation is only strictly required when we define a map that computes the trajectory mean position (map_to_mean = true in OnlineFilterConfig) but we keep the requirement for now.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We define a set of N weight functions. For k = 1N2 we have","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    G_Ck(t) = begincases\n    e^-c_k tcos d_k thspace1cm t  0 \n    0hspace1cm t leq 0\n    endcases\n    G_Sk(t) = begincases\n    e^-c_k tsin d_k t hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"For t0, we have","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We then define a corresponding set of N filtered scalars","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that ","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelreconstitutefstar\n    f^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk labelgCeqn\nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck labelgSeqn\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0 (TODO add more on ICs, spin-up)","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"If we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define ","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"To define perturbation equations, we set:","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"where the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk labelxiCeqn\nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_CklabelxiSeqn\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and solved with initial conditions vb*xi_Ck(vb*x0) = vb*xi_Sk(vb*x0)=0.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#Choosing-offline-filters","page":"Choosing offline filters","title":"Choosing offline filters","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"To be added. ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"TLDR; set N and freq_c in OfflineFilterConfig to get a filter with squared amplitude of a Butterworth order N filter with cutoff frequency freq_c.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"If N=1 then a double sided exponential filter is found. Otherwise, N should be even.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#General-form","page":"Choosing offline filters","title":"General form","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Exponential","page":"Choosing offline filters","title":"Exponential","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Butterworth-(squared)","page":"Choosing offline filters","title":"Butterworth (squared)","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"The filter coefficients are chosen as","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"beginalign\n    a_n = fracomega_cNsinfracpi2N(2n-1) \n    b_n = fracomega_cNcosfracpi2N(2n-1) \n    c_n = omega_csinfracpi2N(2n-1) \n    d_n = omega_ccosfracpi2N(2n-1)\nendalign","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"This choice gives a weight function G(t) with frequency response ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"beginequation\n    hatG(omega) = frac11 + left(omegaomega_cright)^2N\nendequation","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"which approaches a low-pass cutoff filter as N rightarrow infty. ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#Define-your-own","page":"Choosing offline filters","title":"Define your own","text":"","category":"section"},{"location":"theory/filtering_PDEs/#Background:-PDEs-for-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/#Introduction","page":"Background: PDEs for Lagrangian filtering","title":"Introduction","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Lagrangian averaging (or, equivalently, Lagrangian filtering) is an effective way to decompose complex multi-scale flows into wave and mean components, as it allows separation based on intrinsic frequency of processes, that is, frequency in the frame of the flow. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Lagrangian means are usually found by seeding virtual particles in numerical simulations and keeping track of their positions. However, various methods for calculating Lagrangian means through the solution of PDEs have recently been developed (Kafiabad and Vanneste, 2023; Baker et al., 2025; Minz et al., 2025), removing the need for particle tracking. These PDE-based methods are flexible, and allow various ways of computing the Lagrangian mean dependent on the use case. Some considerations include:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Should the filtering be performed online (at simulation time) or offline (after simulation time, using saved data)?\nHow important is the filter shape - can we get away with a less strict low-pass?\nHow often do we need to find the Lagrangian mean? Once per averaging interval, or at every time? ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"These considerations will determine how the Lagrangian average should be performed, and how OceananigansLagrangianFilter is used. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Before describing how to find Lagrangian averages with PDEs, we first describe the simpler case of finding Eulerian averages with ODEs. ","category":"page"},{"location":"theory/filtering_PDEs/#ODEs-for-Eulerian-time-averages","page":"Background: PDEs for Lagrangian filtering","title":"ODEs for Eulerian time averages","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We consider some scalar function f(t) (for now neglecting the spatial dimension), from which we would like to obtain barf, its low-pass filter. We know f only at the current simulation time t, and it can only depend on past times by causality, so we must have ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(t) = int_-infty^t K(ts) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some weight function K(ts), whose shape (a function of s) could depend on the current time t. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We look for an evolution equation of barf and take the time derivative, finding:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabeltime_evol1\n    dotbarf(t) = K(tt) f(t) + int_-infty^t fracpartialpartial tK(ts) mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"To be able to close this equation so that it only depends on information available at the current time, we need either:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"fracpartialpartial tK(ts) = alpha(t)K(ts), so that the integral in \\eqref{time_evol1} can be expressed in terms of barf.\nfracpartialpartial tK(ts) = 0, so that K(ts) equiv G(s), and the weight function G(s) does not change as t increases. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"These two options give rise to different schemes. ","category":"page"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-moving-exponential-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with moving exponential weight functions","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In this case, the most general weight function satisfies fracpartialpartial tK(ts) = alpha(t)K(ts). However, we additionally constrain the weight function by imposing that although the reference time of the weight function changes with the simulation time  t, it's shape should not, so K(ts) = G(t-s), and barf is a convolution between the impulse response G(t) and f. This then implies that ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    K(ts) equiv G(t -s) = alpha e^-alpha (t -s)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some constant alpha. With this special exponential weight function, the normalisation ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    int_-infty^t G(t - s)  ds = 1\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"holds at all times so barf describes the exponential mean at all times (after some initial spin-up), and is given by","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelexponentialODE\n    dotbarf(t) = alpha(f(t) - barf(t))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Therefore, when the weight function G(t) is exponential (or composed of a small number of exponentials, as will be descibed later) equation \\eqref{exponentialODE} can be solved alongside the governing equation for f(t) and the exponential mean found 'on-the-fly'. The methods that are currently implemented in OceananigansLagrangianFilter are based on sums of exponential weight functions.","category":"page"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-fixed-arbitrary-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with fixed arbitrary weight functions","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In this case, the weight function G(s) doesn't shift with the simulation time t, so the low pass variable","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(t) = int_-infty^t G(s) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"only truly describes the low-pass filtered field as t rightarrow infty. The weight function G(s) can take any form, but should satisfy the normalisation ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    int_-infty^infty G(s) mathrmd s = 1\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In reality, we consider some finite interval t^* - T2 t^* + T2 for some reference time t^*, and consider","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(tt^*) = int_t^* - T2^t G(t^* - s) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"where barf(t^* + T2t^*) is our desired output, G(t) is only non-zero on -T2T2, and barf satisfies","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    dotbarf(tt^*) = G(t^* - t)f(t)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We can think of t^*_i = T2 + iT, where T is the averaging interval, and i in 012 as defining a coarse time, and solve for the mean at each t^*_i by reinitialising barf after each time T so that barf(iTt^*_i) = 0.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Methods for filtering with arbitrary weight functions in this way are described in Baker et al. (2025). These are not yet implemented in OceananigansLagrangianFilter, but raise an issue on our github if you're interested in using these methods. ","category":"page"},{"location":"theory/filtering_PDEs/#Online-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Online exponential Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Here, we demonstrate the how the (single) exponential Lagrangian mean can be found online. This is the basic idea behind OceananigansLagrangianFilter, and is a simplified version of the exponential Lagrangian averaging described in (Minz et al., 2025). We define (see Lagrangian averaging for general definitions):","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelsingleexpfstar\n    f^*(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)f(vb*varphi(vb*as)s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some inverse timescale alpha. Taking the time derivative of \\eqref{singleexpfstar} at fixed vb*a, and using the chain rule, gives","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    fracpartial f^*partial t(vb*varphi(vb*at)t) + fracpartial vb*varphipartial t(vb*at)cdot nabla f^*(vb*varphi(vb*at)t) = alpha(f(vb*varphi(vb*at)t) - f^*(vb*varphi(vb*at)t))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Setting vb*varphi(vb*at) = vb*x, and noting that fracpartial vb*varphipartial t (vb*at)= vb*u(vb*varphi(vb*at)t) by definition of the flow map, we have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelfstareqnsingleexp\n    fracpartial f^*partial t(vb*xt) + vb*u cdotnabla f^*(vb*xt) = alpha(f(vb*xt) - f^*(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"This equation can then be solved alongside the dynamical equations of the simulation (which will determine f and vb*u) to find f^* at all times (after some suitable spin-up period). ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"If we also want to find the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging), we define a map","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Taking the time derivative, we find (c.f. \\eqref{fstareqnsingleexp})","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelXieqnsingleexp\n    fracpartial vb*Xipartial t(vb*xt) + vb*u cdotnabla vb*Xi(vb*xt) = alpha(vb*x - vb*Xi(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Defining a perturbation vb*xi(vb*xt) = vb*Xi(vb*xt) - vb*x, we then have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelxieqnsingleexp\n    fracpartial vb*xipartial t(vb*xt) + vb*u cdotnabla vb*xi(vb*xt) = - vb*u - alpha vb*Xi(vb*xt)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"After having solved \\eqref{fstareqnsingleexp} for f^* and \\eqref{xieqnsingleexp} for vb*xi, the relation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"can be used to recover barf^mathrmL by interpolation.","category":"page"},{"location":"theory/filtering_PDEs/#Offline-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Offline exponential Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"While the exponential formulation is efficient as it finds the mean at all times, it limits the possible weight functions, and in particular limits us to causal averages, which depend at any time only on past data. For this reason, we also develop an approach to exponential filtering that combines a 'forward' exponential average (as in \\eqref{fstareqnsingleexp}) with a 'backward' exponential pass. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"For \\eqref{fstareqnsingleexp} to be run `backwards', the filtering must be performed offline and the data therefore saved at wave-resolving resolution. The forward and backward outputs are summed to give a total output with a more desirable effective filter shape, at the expense of the necessity of saving data. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The goal is to find ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    f^*(vb*varphi(vb*at) t) = int_-infty^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"where G(t) is even such that G(t) equiv G(t). ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"This property means that the weight function will be centred on the reference time t, and the frequency response of this filter will be real. Such filters have linear phase shift (or, in this case, zero phase shift,* since G is symmetric about t=0). This means that the phases of frequencies in the pass-band are not modified, in contrast to filters like the single sided exponential used in Online Lagrangian filtering. See Choosing online filters for more explanation of weight functions.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"For a single exponential (as opposed to sums of exponentials, to be introduced in Online Lagrangian filtering equations and Offline Lagrangian filtering equations),","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nG(t-s) = fracalpha2 e^-alphat-s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"i.e. a `double sided exponential'.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"On the forward pass (which can be performed either 'online' at the same time as the simulation, or `offline' on saved data - our implementation does this offline since data must be saved for the backward pass anyway) we calculate","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    f^*_1(vb*varphi(vb*at) t) = int_-infty^t G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"and on the backward pass (which must be performed offline) we calculate ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2star\n    f^*_2(vb*varphi(vb*at) t) = int_t^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"such that f^* = f^*_1 + f^*_2.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The forward equation is identical to the online scheme \\eqref{fstareqnsingleexp}, aside from a factor of two to ensure that the normalisation of the weight function still holds:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf1stareqnsingleexp\n    fracpartial f^*_1partial t(vb*xt) + vb*u cdotnabla f^*_1(vb*xt) = fracalpha2(f(vb*xt) - f^*_1(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The backward equation is found by first taking the time derivative of \\eqref{f2star} to give","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp\n    fracpartial f^*_2partial t(vb*xt) + vb*u cdotnabla f^*_2(vb*xt) = -fracalpha2(f(vb*xt) - f^*(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"then setting tildet = T - t, where T is the total simulation time (or end of the desired averaging interval), to give","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp_timereversed\n    fracpartial f^*_2partial tildet(vb*xT - tildet) - vb*u cdotnabla f^*_2(vb*xT - tildet) = fracalpha2(f(vb*xT - tildet) - f^*(vb*xT - tildet))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Defining tildef^*_2(vb*xtildet) = f^*_2(vb*xT-tildet), tildef(vb*xtildet) = f(vb*xT-tildet), and tildevb*u(vb*xtildet) = vb*u(vb*xT-tildet), we then have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp_tilde\n    fracpartial tildef^*_2partial tildet(vb*xtildet) + tildevb*u cdotnabla tildef^*_2(vb*xtildet) = fracalpha2(f(vb*xtildet) - tildef^*(vb*xtildet))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"which is equivalent to \\eqref{f1stareqnsingleexp} solved backwards with negated velocities. Equations for the forward and backward maps vb*Xi_1 and vb*Xi_2 (c.f. \\eqref{Xidefonline}) can be found similarly by setting f to the identity in \\eqref{fstareqnsingleexp} and \\eqref{f2stareqnsingleexp_tilde}.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Having found f_1^* on the forward pass, and tildef_2^* on the backward pass, we then calculate ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nf^*(vb*xt) = f_1^*(vb*xt) + tildef_2^*(vb*xT-t)\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-and-Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The Eulerian weighted temporal mean of some scalar f is defined as","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\nlabelfbarEdef\n    barf^mathrmE(vb*xt) = int_-infty^infty G(t-s)f(vb*xs)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"where G(t) is some weight function, also referred to as a filter kernel or impulse response. The Fourier transform of G(t) is denoted hatG(omega), and is the frequency response of the weight function. Here, we will generally want G(t) to represent a low-pass filter, which retains the low frequencies and removes high frequencies. For example, two possible choices of weight function are ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"Top-hat impulse response: G(t) = begincases 1T  hspace1cm -T2  t  T2  0 hspace1cm mathrmotherwiseendcases\nTop-hat frequency response:  hatG(omega) = begincases 1  hspace1cm -omega_c  omega  omega_c  0 hspace1cm mathrmotherwiseendcases","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The Eulerian mean barf^mathrmE(vb*xt) is the field found by taking an average in time at a fixed spatial location vb*x. ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/#Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Lagrangian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"In contrast, the Lagrangian mean finds the temporal average whilst moving with the flow on an (imaginary) fluid particle. We define the Lagrangian weighted temporal mean as ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\nlabelfbardef\n    barf^mathrmL(barvb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"where the flow map  vb*varphi(vb*at) is the position at time t of a particle with label vb*a (which could be the initial position of the particle such that vb*varphi(vb*a0) = vb*a). The mean flow map barvb*varphi is defined by","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequationlabelphibardef\nbarvb*varphi(vb*a t) = int_-infty^infty G(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The definition \\eqref{fbardef} ensures that barf^mathrmL is the true generalised Lagrangian mean, in that (for strict band-pass filters) applying the same averaging procedure to the mean flow itself leaves it unchanged (Baker et al., 2025). However, we also define an alternative Lagrangian mean, which is a rearrangement of barf^mathrmL:","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"While barf^mathrmL(vb*xt) describes the average along a particle trajectory whose mean position is vb*x, f^*(vb*xt) defines the average along a particle trajectory whose position is vb*x at time t. It is often more desirable, or more convenient, to find f^* instead. If barf^mathrmL is also needed, it can be found by a rearrangement of f^* using a map","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\n    vb*Xi(vb*varphi(vb*at)t) = barvb*varphi(vb*at)\nendequation","category":"page"},{"location":"offline_filtering/offline_how_it_works/#How-it-works","page":"How it works","title":"How it works","text":"","category":"section"},{"location":"offline_filtering/offline_how_it_works/","page":"How it works","title":"How it works","text":"To be added (see run_offline_lagrangian_filter.jl)","category":"page"},{"location":"#OceananigansLagrangianFilter.jl","page":"Home","title":"OceananigansLagrangianFilter.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package to compute Lagrangian temporal filters of Oceananigans.jl simulation output","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Lagrangian filter can be run in two ways","category":"page"},{"location":"","page":"Home","title":"Home","text":"Online: integrated into your Oceananigans simulation. This avoids the need to save data at wave-resolving resolution, but the available filter shapes are not as desirable. \nOffline: run after your Oceananigans simulation (or, feasibly, on any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the fields to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. ","category":"page"}]
}
