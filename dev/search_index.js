var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Baker,Â L.Â E.; Kafiabad,Â H.Â A.; Maitland-Davies,Â C. and Vanneste,Â J. (2025). Lagrangian Filtering for Waveâ€“Mean Flow Decomposition. JournalÂ ofÂ FluidÂ Mechanics 1009, A40.\n\n\n\nKafiabad,Â H.Â A. and Vanneste,Â J. (2023). Computing Lagrangian Means. JournalÂ ofÂ FluidÂ Mechanics 960, A36.\n\n\n\nMinz,Â A.; Baker,Â L.Â E.; Kafiabad,Â H.Â A. and Vanneste,Â J. (2025). Efficient Lagrangian Averaging with Exponential Filters. Phys.Â Rev.Â Fluids 10, 074902.\n\n\n\nWagner,Â G.Â L.; Silvestri,Â S.; Constantinou,Â N.Â C.; Ramadhan,Â A.; Campin,Â J.-M.; Hill,Â C.; Chor,Â T.; Strong-Wright,Â J.; Lee,Â X.Â K.; Poulin,Â F.; Souza,Â A.; Burns,Â K.Â J.; Marshall,Â J. and Ferrari,Â R. (2025). High-level, high-resolution ocean modeling at all scales with Oceananigans, arXivÂ preprint, arXiv:2502.14148.\n\n\n\n","category":"page"},{"location":"offline_filtering/offline_implementation/#Offline-filtering-implementation","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"","category":"section"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"The offline Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved after the original Oceananigans simulation (or, feasibly, using any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the tracer(s) f to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. ","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"The offline filter uses mostly the same functions as the online filter to define filtered fields and their forcings, but in this case most of the process is 'under the hood', as the user only needs to provide the simulation data and specify the configuration. An example is given in offlinefiltergeostrophic_adjustment.jl, and more detail on how it works is given in How it works.","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"A short example of how to implement offline filtering on a GPU is given below:","category":"page"},{"location":"offline_filtering/offline_implementation/","page":"Offline filtering implementation","title":"Offline filtering implementation","text":"using OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"ðŸ› ï¸ Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For now, you can install the package from github. With a fresh or existing julia environment activated, either  access the Pkg REPL and use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"or in julia:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url = \"https://github.com/loisbaker/OceananigansLagrangianFilter.jl.git\")\n","category":"page"},{"location":"online_filtering/choosing_online_filters/#Choosing-online-filters","page":"Choosing online filters","title":"Choosing online filters","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"To be added. ","category":"page"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"Quick version: set N and freq_c in OnlineFilterConfig to get a Butterworth filter of order N with cutoff frequency freq_c.","category":"page"},{"location":"online_filtering/choosing_online_filters/","page":"Choosing online filters","title":"Choosing online filters","text":"If N=1 then an exponential filter is found. Otherwise, N should be even. ","category":"page"},{"location":"online_filtering/choosing_online_filters/#General-form","page":"Choosing online filters","title":"General form","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Exponential","page":"Choosing online filters","title":"Exponential","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Butterworth","page":"Choosing online filters","title":"Butterworth","text":"","category":"section"},{"location":"online_filtering/choosing_online_filters/#Define-your-own","page":"Choosing online filters","title":"Define your own","text":"","category":"section"},{"location":"online_filtering/online_implementation/#Online-filtering-implementation","page":"Online filtering implementation","title":"Online filtering implementation","text":"","category":"section"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"The online Lagrangian filter equations, which find Lagrangian filtered tracer(s) f^* (see Lagrangian averaging for a definition) are solved at the same time as the governing equations of your simulation, in which the original tracer f is being found. Filtered velocities can also be found. This means that equations for the filtered tracers, and optionally the maps (see Online Lagrangian filtering equations) need to be passed to your model. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"OceananigansLagrangianFilter provides helper functions to define these extra fields and their forcings, and an example is given in onlinefiltergeostrophic_adjustment.jl. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Other helper functions are provided to initialise the filtered variables, define output fields that compute f^*, regrid f^* to barf^mathrmL (see Lagrangian averaging), compute the Eulerian filter for comparison, compute a shifted time variable, and output a final NetCDF file. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"We summarise here the protocol for implementing online Lagrangian filtering","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Install OceananigansLagrangianFilter in your environment (see Quick Start).\nLoad OceananigansLagrangianFilter and its utility functions at the top of your script. This automatically loads Oceananigans.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"using OceananigansLagrangianFilter\nusing OceananigansLagrangianFilter.Utils","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Setup your parameters, grid, tracers, and forcing as normal\nDefine your filter_config - an OnlineFilterConfig. This takes as arguments:\ngrid: the grid you have already defined\noutput_filename: a filename to save filtered output to\nvar_names_to_filter: a tuple of strings defining the names of variables to filter. These can be any of your tracers. Velocities to filter don't need to be listed here (see below).\nvelocity_names: the velocity names that you want to use to compute Lagrangian trajectories. These are also the velocities that will be filtered if compute_mean_velocities = true.\nN and freq_c: Can be provided together to give a Butterworth filter of order N with cutoff frequency freq_c. \nfilter_params: a named tuple of coefficients a1, b1, c1, d1, a2, b2, c2, d2, etc defining a filter kernel (see Choosing online filters).\nmap_to_mean: A Bool determining whether to compute the maps vb*xi_Ck and vb*xi_Sk and solve their equations (see Online Lagrangian filtering equations).\ncompute_mean_velocities: A Bool determining whether to compute and output the mean velocities. They are computed from the maps vb*xi_Ck and vb*xi_Sk, so if map_to_mean=false and compute_mean_velocities=true the maps will still be computed. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = filename_stem * \".jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = f/2)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Create the filtered variables g_Ck, g_Sk, vb*xi_Ck and vb*xi_Sk using the function create_filtered_vars, which only needs the filter_config. These filtered variables will be added to the model as tracers.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filtered_vars = create_filtered_vars(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Create forcing for these filtered variables using the function create_forcing. This implements the right-hand-sides of the tracer and map equations (see Online Lagrangian filtering equations). Merge this filter_forcing with your existing forcing. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"filter_forcing = create_forcing(filtered_vars, filter_config)\nforcing = merge(forcing, filter_forcing);","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"If you're using a closure, you'll need to tell the filtered scalars not to use a closure (although they could be given a closure if necessary for stability - this has proved unecessary so far and is more accurate). A helper function zero_closure_for_filtered_vars to set the diffusivity to zero for each of the filtered variables is provided.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"zero_filtered_var_closure = zero_closure_for_filtered_vars(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the closure for your model variables using the zero_filtered_var_closure","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"horizontal_closure = HorizontalScalarDiffusivity(Î½=1e-6, Îº=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nvertical_closure = VerticalScalarDiffusivity(Î½=1e-6 , Îº=merge((T=1e-6, b= 1e-6),zero_filtered_var_closure) )\nclosure = (horizontal_closure, vertical_closure)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the model with the combined (original and filtered) tracers, forcing and closure. This should work with both NonHydrostaticModel and HydrostaticFreeSurfaceModel.\nInitialise your model variables as normal\nInitialise the filtered variables (this uses the previously initialised model variables to give a better initialisation, so needs to be performed after the previous step)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"initialise_filtered_vars_from_model(model, filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define the simulation, any callbacks, conjure_time_step_wizard, etc as normal\nUse the create_output_fields helper function to define the output fields (this defines the outputs f^* and vb*Xi so that all of the intermediate filter variables are not output by default, though they could be examined as for any other tracer)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"outputs = create_output_fields(model, filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Add in any other output fields, including the original fields if desired (not included by default in the online filter).","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"outputs[\"b\"] = model.tracers.b\noutputs[\"T\"] = model.tracers.T\noutputs[\"u\"] = model.velocities.u\noutputs[\"v\"] = model.velocities.v\noutputs[\"w\"] = model.velocities.w","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Define a JLD2Writer for the outputs. The filename should be the same as filter_config.output_filename. For the post-processing functions provided in the next few steps, this does need to be a JLD2Writer rather than a NetCDFWriter, but a helper function is provided to output a final .nc file if needed. \nRun the simulation","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"run!(simulation)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally regrid to mean position using regrid_to_mean_position!. This adds a new field to the output data file.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"if filter_config.map_to_mean\n    regrid_to_mean_position!(filter_config)\nend","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally compute the Eulerian filter (with the same filter_params) using compute_Eulerian_filter!.","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"compute_Eulerian_filter!(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally compute a shifted time coordinate to give a more appropriate reference time for the average. The new reference time is calculated as the weighted mean of time: t_shift = int_-infty^t G(t-s)s mathrmd s","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"compute_time_shift!(filter_config)","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"Optionally output a final NetCDF file using jld2_to_netcdf. This helper function should work for any .jld2 Oceananigans output. ","category":"page"},{"location":"online_filtering/online_implementation/","page":"Online filtering implementation","title":"Online filtering implementation","text":"jld2_to_netcdf(filename_stem * \".jld2\", filename_stem * \".nc\")","category":"page"},{"location":"library/#OceananigansLagrangianFilter.jl-Library","page":"Library","title":"OceananigansLagrangianFilter.jl Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documenting the public user interface.","category":"page"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(;\n\n)\n\nA configuration object for online filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OnlineLagrangianFilter.OnlineFilterConfig","text":"OnlineFilterConfig(; grid::AbstractGrid,\n                        output_filename::String = \"online_filtered_output\",\n                        var_names_to_filter::Tuple{Vararg{String}},\n                        velocity_names::Tuple{Vararg{String}},\n                        N::Union{Int, Nothing} = nothing,\n                        freq_c::Union{Int, Nothing} = nothing,\n                        filter_params::Union{NamedTuple, Nothing} = nothing,\n                        map_to_mean::Bool = true,\n                        compute_mean_velocities::Bool = true,\n                        npad::Int = 5,\n                        filter_mode::String = \"online\"\n                        )\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\ngrid: (required) The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\noutput_filename: The filename for the output of the online filtered data. Default: \"online_filtered_output\".\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nN, freq_c: Parameters for a Butterworth filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"online\". TODO use multiple dispatch for this instead.\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\n\nNx = 50\nNz = 20\nL = 10kilometers \nH = 100meters \n\ngrid = RectilinearGrid(CPU(),size = (Nx, Nz), \n                       x = (-L/2, L/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))\n\nfilter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = \"test_filter.jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"), \n                                    velocity_names = (\"u\",\"w\"),\n                                    N = 2,\n                                    freq_c = 1e-4/2)\n\n# output\n\n[ Info: Setting filter parameters to use Butterworth order 2, cutoff frequency 5.0e-5\nOnlineFilterConfig(50Ã—1Ã—20 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=200.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=5.0, \"test_filter.jld2\", (\"b\", \"T\"), (\"u\", \"w\"), (a1 = 1.421067568548072e-20, b1 = -7.071067811865475e-5, c1 = 3.535533905932738e-5, d1 = -3.535533905932738e-5, N_coeffs = 1), true, true, 5, \"online\")\n\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(;\n    \n)\n\nA configuration object for apply_offline_filter.\n\n\n\n\n\n","category":"type"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.OfflineFilterConfig","text":"OfflineFilterConfig(; original_data_filename::String,\n                    var_names_to_filter::Tuple{Vararg{String}},\n                    velocity_names::Tuple{Vararg{String}},\n                    T_start::Union{Real,Nothing} = nothing,\n                    T_end::Union{Real,Nothing} = nothing,\n                    T::Union{Real,Nothing} = nothing,\n                    architecture::AbstractArchitecture = CPU(),\n                    T_out::Union{Real,Nothing} = nothing,\n                    N::Union{Int, Nothing} = nothing,\n                    freq_c::Union{Int, Nothing} = nothing,\n                    filter_params::Union{NamedTuple, Nothing} = nothing,\n                    Î”t::Union{Real,Nothing} = nothing,\n                    backend::AbstractInMemoryBackend = InMemory(4),\n                    map_to_mean::Bool = true,\n                    forward_output_filename::String = \"forward_output.jld2\",\n                    backward_output_filename::String = \"backward_output.jld2\",\n                    output_filename::String = \"filtered_output.jld2\",\n                    npad::Int = 5,\n                    compute_mean_velocities::Bool = true,\n                    delete_intermediate_files::Bool = true,\n                    compute_Eulerian_filter::Bool = false,\n                    output_netcdf::Bool = false,\n                    output_original_data::Bool = true\n                    advection::AbstractAdvectionScheme = WENO(),\n                    grid::Union{AbstractGrid, Nothing} = nothing,\n                    filter_mode::String = \"offline\")\n\nConstructs a configuration object for offline Lagrangian filtering of Oceananigans data. This function validates the input data file, time specifications, and filter parameters before creating the OfflineFilterConfig object.\n\nKeyword arguments\n\noriginal_data_filename: (required) The path to the JLD2 file containing the original Oceananigans output data.\nvar_names_to_filter: (required) A Tuple of Strings specifying the names of the tracer variables to be filtered.\nvelocity_names: (required) A Tuple of Strings specifying the names of the velocity fields in the data file to be used for advection.\nT_start: Start time for the filter. Must be within the time range of the data. If not given, defaults to either T_end - T (if they are given), or the start time of the original data.\nT_end: End time for the filter. Must be within the time range of the data. If not given, defaults to either Tstart + T (after Tstart given or computed, if T is given), or the end time of the original data.\nT: Duration of the filtering. If not given, defaults to Tend - Tstart (after Tstart and Tend are given or computed).\narchitecture: The architecture (CPU or GPU) to be used for the filtering computation. Default: CPU().\nT_out: The output time step for the filtered data. If nothing, it defaults to the time step of the original data.\nN, freq_c: Parameters for a Butterworth squared filter. N is the order of the filter, and freq_c is the cutoff frequency.   These are used to automatically generate filter_params if not provided. Must be specified together if filter_params is not given.\nfilter_params: A NamedTuple containing the coefficients for a custom filter. Only filterparams OR N and `freqc` should be given.\nÎ”t: The time step for the internal Lagrangian filter simulation. If nothing, it defaults to T_out / 10, but this may not be appropriate.\nbackend: The backend for loading FieldTimeSeries data. See Oceananigans.Fields.FieldTimeSeries. Default: InMemory(4).\nmap_to_mean: A Bool indicating whether to map filtered data to the mean position (i.e. calculate generalised Lagrangian mean). Default: true.\nforward_output_filename: The filename for the output of the forward filter pass. Default: \"forward_output.jld2\".\nbackward_output_filename: The filename for the output of the backward filter pass. Default: \"backward_output.jld2\".\noutput_filename: The filename for the final combined and mapped output. Default: \"filtered_output.jld2\".\nnpad: The number of cells to pad the interpolation to mean position, used when there are periodic boundary conditions. Default: 5.\ncompute_mean_velocities: A Bool indicating whether to compute the mean velocities from the maps. Default: true.\ndelete_intermediate_files: A Bool indicating whether to delete forward_output.jld2 and backward_output.jld2 after the final combined file is created. Default: true.\ncompute_Eulerian_filter: A Bool indicating whether to also compute an Eulerian-mean-based filter for comparison. Default: false.\noutput_netcdf: A Bool indicating whether to also convert the final JLD2 output file to a NetCDF file. Default: false.\noutput_original_data: A Bool indicating whether to include the original data in the final output file for comparison. Default: true.\nadvection: The advection scheme to use for the Lagrangian filter simulation. Default: WENO(). Using lower-order schemes may be a source of error.\ngrid: The grid for the simulation. If nothing, the grid is inferred from the original_data_filename (preferred option)\nfilter_mode: A String indicating whether to run the filter in \"offline\" or \"online\" mode. Default: \"offline\". TODO use multiple dispatch for this instead.\n\nExample:\n\nusing OceananigansLagrangianFilter\nusing Oceananigans.Units\npath_to_sim = \"../test/data/reference_sim.jld2\"\nfilter_config = OfflineFilterConfig(original_data_filename=path_to_sim, \n                                    output_filename = \"output_file.jld2\", \n                                    var_names_to_filter = (\"b\",), \n                                    velocity_names = (\"u\",\"w\"), \n                                    architecture = CPU(), \n                                    Î”t = 20minutes, \n                                    T_out = 1hour, \n                                    N = 2, \n                                    freq_c = 1e-4/2, \n                                    compute_mean_velocities = true, \n                                    output_netcdf = true, \n                                    delete_intermediate_files = true, \n                                    compute_Eulerian_filter = true) \n\n# output\n\n[ Info: Filter interval will be from T_start=0.0 to T_end=86400.0, duration T=86400.0\n[ Info: Setting filter parameters to use Butterworth squared, order 2, cutoff frequency 5.0e-5\nOfflineFilterConfig(\"../test/data/reference_sim.jld2\", (\"b\",), (\"u\", \"w\"), 0.0, 86400.0, 86400.0, CPU(), 3600.0, (a1 = 1.767766952966369e-5, b1 = 1.767766952966369e-5, c1 = 3.535533905932738e-5, d1 = 3.535533905932738e-5, N_coeffs = 1), 1200.0, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"output_file.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=4), 10Ã—1Ã—10 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=1000.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=10.0, \"offline\")\n\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter-Tuple{Any}","page":"Library","title":"OceananigansLagrangianFilter.OfflineLagrangianFilter.run_offline_Lagrangian_filter","text":"run_offline_Lagrangian_filter(config::OfflineFilterConfig)\n\nRuns an offline Lagrangian filter on an Oceananigans FieldTimeSeries dataset as configured by config.\n\nThis function performs a series of steps to filter the data:\n\nPrepare data on disk: The input data is copied and manipulated on disk to be suitable for the forward and backward Lagrangian simulations.\nRun forward simulation: A LagrangianFilter model is created and run forward in time to compute the first half of the filter contributions.\nRun backward simulation: The input data is re-prepared for a backward pass, and the simulation is run a second time to compute the remaining contributions.\nCombine results: The forward and backward simulation outputs are summed to produce the final filtered data.\nPost-processing: Optional post-processing steps are performed, including regridding the data to the mean position, computing a comparative Eulerian filter, and converting the output file to NetCDF.\nCleanup: Intermediate files are removed to save disk space.\n\nArguments\n\nconfig: An instance of OfflineFilterConfig that specifies all parameters and file paths for the filtering process.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils","page":"Library","title":"OceananigansLagrangianFilter.Utils","text":"","category":"section"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_Eulerian_filter!","text":"compute_Eulerian_filter!(config::AbstractConfig)\n\nComputes the Eulerian filter for specified variables and writes the results to a combined output file. This function performs a direct, convolution-style filtering of a time series by applying a weighting function to the data at each time step.\n\nThe function iterates through each variable to be filtered:\n\nReads data: The entire time series of the variable is read from the  JLD2 file.\nApplies weighting: At each output time, a weighting function G is  computed and applied to the entire time series. The weighted data is summed  to produce the filtered field.\nWrites output: The resulting filtered field is saved back to the  same JLD2 file in a new group with the _Eulerian_filtered suffix.\n\nThis method serves as a benchmark for comparison with the main Lagrangian filter.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, and filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.compute_time_shift!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.compute_time_shift!","text":"compute_time_shift!(config::AbstractConfig)\n\nComputes the time shift for an online filter based on its coefficients and writes the shifted time series to the output file.\n\nThis function is only applicable for online filtering. The time shift is computed as the time delay introduced by the filter's transfer function. This new time series is stored in a new group called timeseries/t_shifted within the output JLD2 file.\n\nArguments\n\nconfig: A configuration object of type OfflineFilterConfig which contains the filter_mode, output_filename, and filter_params (filter coefficients).\n\nThrows\n\nerror: If config.filter_mode is not \"online\". The time shift for offline (forward-backward) filtering is zero by definition due to an even weight function.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_filtered_vars","text":"create_filtered_vars(config::AbstractConfig)\n\nCreates a Tuple of Symbols representing the names of the filtered tracer variables.\n\nFor a single-exponential filter (N_coeffs = 0.5), the function generates names with a _C1 suffix.\nFor a multi-coefficient filter (N_coeffs > 0.5), it generates pairs of names for each coefficient, suffixed with _C# and _S#, where # is the coefficient index.\n\nIf map_to_mean or compute_mean_velocities is enabled in the configuration, additional symbols are created for the spatial mapping variables corresponding to each velocity component, prefixed with xi_ and suffixed with the corresponding coefficient names.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables to filter, the filter parameters, and the map_to_mean and compute_mean_velocities booleans.\n\nReturns\n\nA Tuple of Symbols representing the names of the filtered variables to be used as tracers in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_forcing-Tuple{Tuple{Vararg{Symbol}}, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_forcing","text":"create_forcing(filtered_vars::Tuple{Vararg{Symbol}}, config::AbstractConfig)\n\nCreates a NamedTuple of forcing functions for each filtered variable and, if enabled, for the spatial mapping variables. These forcing terms are used to numerically integrate the filter equations.\n\nThe function handles two cases: a single-exponential filter (N_coeffs = 0.5) and a multi-coefficient Butterworth squared filter (N_coeffs > 0.5).\n\nFor standard filtered variables, the forcing is a combination of terms derived from the filter's coefficients and a term from the original data.\nFor spatial mapping variables (if map_to_mean or compute_mean_velocities is true), the forcing includes terms derived from the filter's coefficients and a term from the original velocity data.\n\nArguments\n\nfiltered_vars: A Tuple of Symbols representing the names of the filtered variables.\nconfig: An instance of AbstractConfig containing the names of the variables to be filtered, velocity names, and the filter parameters.\n\nReturns\n\nA NamedTuple where each key is a variable name from filtered_vars and each value is a Tuple of the corresponding forcing functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_input_data_on_disk-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_input_data_on_disk","text":"create_input_data_on_disk(config::AbstractConfig; direction::String=\"forward\")\n\nPrepares a new JLD2 file on disk with the time-filtered data for a forward or backward Lagrangian simulation.\n\nThis function performs the following steps:\n\nValidates direction: Ensures the direction is either \"forward\"  or \"backward\".\nCreates a new file: A new JLD2 file is created with the suffix  _filter_input.jld2 and any existing file with the same name is deleted.\nCopies metadata: Key metadata from the original file (e.g., grid  information) is copied to the new file to maintain consistency.\nTime truncation: The data is truncated to the time range specified by  config.T_start and config.T_end.\nTime shifting:\nFor \"forward\" filtering, a new time variable is created, shifted so   that t=0 corresponds to config.T_start.\nFor \"backward\" filtering, the data is re-ordered and a new time   variable is created, shifted so that t=0 corresponds to config.T_end.\nVelocity reversal: For \"backward\" filtering, the velocity fields  (u, v, w) are negated to correctly simulate backward advection.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and time specifications.\n\nKeyword Arguments\n\ndirection: A String indicating the simulation direction. It must be either \"forward\" (the default) or \"backward\".\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_original_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_original_vars","text":"create_original_vars(config::AbstractConfig)\n\nCreates a NamedTuple of CenterFields to serve as auxiliary fields for the original variables in a simulation. The fields are instantiated on the grid specified in the config object.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the names of the variables and the simulation grid.\n\nReturns\n\nA NamedTuple where each key is a Symbol of a variable name to be filtered, and each value is an empty CenterField for that variable.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.create_output_fields-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.create_output_fields","text":"create_output_fields(model::AbstractModel, config::AbstractConfig)\n\nReconstructs the final output fields from the model's tracers and auxiliary fields. This function performs the following steps:\n\nReconstructs filtered variables: For each variable to be filtered, it sums  the contributions from the individual filter coefficients (_C and _S  tracers) using the coefficients from filter_params.\nReconstructs spatial mapping fields: If spatial mapping is enabled,  the function also reconstructs the xi_ fields that represent the filtered  position.\nBuilds mean velocities: If compute_mean_velocities is true, the function  reconstructs the mean velocity fields using the xi_ fields.\nIncludes original data: The original data is added to the output  dictionary for comparison and analysis if config.output_original_data  is true.\n\nArguments\n\nmodel: An instance of an AbstractModel containing the tracer and auxiliary fields.\nconfig: An instance of AbstractConfig with the names of the variables, velocity components, and filter parameters.\n\nReturns\n\nA Dict where keys are the names of the output fields (e.g., var_name_Lagrangian_filtered, xi_vel_name, var_name) and values are the corresponding reconstructed Fields.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_frequency_response-Tuple{AbstractArray, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_frequency_response","text":"get_frequency_response(freq::AbstractArray, filter_params::NamedTuple)\n\nCalculates the frequency response of the offline filter. This function takes a set of frequencies and the filter's coefficients to compute how the filter amplifies or attenuates different frequency components of a signal.\n\nThe response is computed by summing the contributions of each coefficient pair based on the filter's transfer function in the frequency domain. The result is a measure of the filter's gain at each given frequency.\n\nArguments\n\nfreq: A vector of frequencies (in radians per unit time).\nfilter_params: A NamedTuple containing the filter coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\n\nReturns\n\nA vector Ghat representing the filter's frequency response at each corresponding frequency in freq.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.get_weight_function-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.get_weight_function","text":"get_weight_function(;t::AbstractArray, tref::Real, filter_params::NamedTuple, direction::String = \"both\")\n\nComputes the weighting function for the offline filter. This function calculates the filter's impulse response, which determines how much each point in the timeseries t contributes to the filtered value at a reference time tref. The weighting function is based on the provided filter_params, which contains the coefficients for the filter's impulse response.\n\nKeyword arguments\n\nt: A collection of time points in the timeseries.\ntref: The reference time at which the filter is being evaluated.\nfilter_params: A NamedTuple containing the coefficients (a, b, c, d) and the number of coefficient pairs (N_coeffs).\ndirection: A String indicating the direction of the filter. It can be \"both\" (default), \"forward\", or \"backward\". This determines whether the filter is applied symmetrically around tref, only to past times, or only to future times.\n\nReturns\n\nA vector of weights G, with the same dimensions as t, representing the value of the filter's impulse response at each time point relative to tref.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data-Tuple{Oceananigans.AbstractModel, NamedTuple, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_data","text":"initialise_filtered_vars_from_data(model::AbstractModel, saved_original_vars::Tuple,\n                         config::AbstractConfig)\n\nInitializes the model's tracer fields, which represent the components of the filtered variables. This function sets the initial values of the filtered variables to the (scaled) first timestep of the original data. This improves the \"spin-up\" of the filter simulation by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nsaved_original_vars: A Tuple of FieldTimeSeries objects containing the original data for each variable.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model-Tuple{Oceananigans.AbstractModel, OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.initialise_filtered_vars_from_model","text":"initialise_filtered_vars_from_model(model::AbstractModel,config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.jld2_to_netcdf-Tuple{String, String}","page":"Library","title":"OceananigansLagrangianFilter.Utils.jld2_to_netcdf","text":"jld2_to_netcdf(jld2_filename::String, nc_filename::String)\n\nConverts a JLD2 output file generated by an Oceananigans simulation into a standard NetCDF file. This function is useful for post-processing and for sharing data with other tools that expect the NetCDF format.\n\nThe conversion process involves the following steps:\n\nRead JLD2 data: Opens the input JLD2 file and reads the grid, time,  and all timeseries variables.\nCreate NetCDF file: Creates a new NetCDF file with a .nc extension.\nDefine dimensions: Defines NetCDF dimensions based on the grid sizes  and staggered locations (e.g., x_caa for cell centers, x_faa for  cell faces).\nDefine grid variables: Writes the grid coordinates and metadata  (e.g., Lx, Ny, Hx) as variables to the NetCDF file.\nWrite timeseries data: Iterates through each variable in the JLD2  file's timeseries, determines its location on the grid, and writes the  data to a new variable in the NetCDF file.\nAdd metadata: Adds attributes to each variable, including boundary  conditions and units, for better documentation.\n\nArguments\n\njld2_filename: A String specifying the path to the input JLD2 file.\nnc_filename: A String specifying the path for the output NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.load_data-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.load_data","text":"load_data(config::AbstractConfig)\n\nLoads the velocity and tracer data from the intermediate input file created by create_input_data_on_disk. The data for each variable is loaded as a FieldTimeSeries and returned as a single NamedTuple.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file path, variable names, \n\narchitecture, and backend.\n\nReturns\n\nA NamedTuple with fields velocity_data and var_data, where each field contains a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.regrid_to_mean_position!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.regrid_to_mean_position!","text":"regrid_to_mean_position!(config::AbstractConfig)\n\nRegrids the filtered data to the mean position. This function reads the combined  output file, interpolates the filtered variables to the mean position, and saves the result in new variables within the same file.\n\nThe regridding process involves the following steps:\n\nExtracts positions: The mean positions (xi_u, xi_v, xi_w) and  filtered variable data are extracted for each time step.\nHandles periodicity: For periodic dimensions (x, y, or z), the data is  padded by repeating values near the boundaries to ensure accurate  interpolation across the periodic boundaries.\nInterpolates data: A linear interpolator is used to map the filtered data  from the irregular advected positions to the original, regular grid points.\nSaves new fields: The regridded data is saved as new variables in the  combined output file, with a _Lagrangian_filtered_at_mean suffix.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths, variable names, and grid information.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_offline_BW2_filter_params","text":"set_offline_BW2_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c, squared. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: Ghat(omega) = 1 / (1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*abs(t))*(a_i*cos(d_i * abs(t)) + b_i*sin(d_i * abs(t)))\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth squared filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.set_online_BW_filter_params-Tuple{}","page":"Library","title":"OceananigansLagrangianFilter.Utils.set_online_BW_filter_params","text":"set_online_BW_filter_params(; N::Int=1, freq_c::Real=1)\n\nCalculates the coefficients for a filter that has a frequency response given by a Butterworth filter with order N and cutoff frequency freq_c. Note that the frequency response is not squared, like in the offline forward-backward filter, and the frequency response is not real-valued, implying a nonlinear phase shift. \n\nUses N exponentials and N/2 sets of coefficients (a,b,c,d). N should therefore be even, since exponentials come in pairs to ensure a real-valued filter.\n\nHowever, the special case N=1 is allowed, which gives a single (real) exponential filter.\n\nFrequency response: abs(Ghat(omega)) = 1 / sqrt(1 + (omega / freq_c)^(2*N)) Real filter shape: G(t) = sum_{i=1}^{N/2} exp(-c_i*t)* (a_i*cos(d_i * t) + b_i*sin(d_i * t))  for t>=0, and 0 for t<0.\n\nThis function supports two types of filters:\n\nA single exponential filter when N=1. This is a special case that generates two coefficients instead of 4. The unidirectional filter is a single exponential, and N_coeffs = 0.5. Only a1 and c1 are returned.\nA Butterworth filter for N>1. This generates N/2 sets of coefficients (a,b,c,d), representing a filter of order N. The coefficients are computed based on the filter's order and cutoff frequency.\n\nArguments\n\nN: The order parameter for the filter. N=1 for a single exponential. For N>1, the filter's order is N. Must be a non-negative even integer.\nfreq_c: The cutoff frequency of the filter. Must be a real number.\n\nReturns\n\nA NamedTuple containing the filter coefficients and N_coeffs, the number of coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.sum_forward_backward_contributions!","text":"sum_forward_backward_contributions!(config::AbstractConfig)\n\nCombines the output from the forward and backward filter simulations into a single output file. This function performs the final step of the offline filter algorithm by summing the contributions from each pass.\n\nThe function performs the following steps:\n\nInitializes the combined file: A new JLD2 file is created to store  the final output.\nCopies metadata and unfiltered data: The file structure, metadata,  and the original, unfiltered data are copied from the forward output file.\nSums filtered contributions: For each filtered variable, the data  from the backward output file is loaded as a FieldTimeSeries. The data  is then interpolated to match the time steps of the forward simulation,  and the two datasets are summed and written to the combined output file.\n\nArguments\n\nconfig: An instance of AbstractConfig containing the file paths and variable names.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.update_input_data!-Tuple{Simulation, NamedTuple}","page":"Library","title":"OceananigansLagrangianFilter.Utils.update_input_data!","text":"update_input_data!(sim::Simulation, input_data::NamedTuple)\n\nUpdates the velocity and auxiliary fields of a simulation at the current simulation time t. This function is designed to be used as a callback in an Oceananigans Simulation.\n\nThe function performs two main tasks:\n\nUpdates velocities: It sets the u, v, and w velocity fields of  the model to the corresponding data from the velocity_data  FieldTimeSeries at the current simulation time.\nUpdates auxiliary fields: It updates the auxiliary fields of the  model with the original data from the var_data FieldTimeSeries, which  are used for forcing terms.\n\nArguments\n\nsim: The Simulation object.\ninput_data: A NamedTuple containing velocity_data and var_data, where each field is a Tuple of FieldTimeSeries objects.\n\n\n\n\n\n","category":"method"},{"location":"library/#OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars-Tuple{OceananigansLagrangianFilter.AbstractConfig}","page":"Library","title":"OceananigansLagrangianFilter.Utils.zero_closure_for_filtered_vars","text":"zero_closure_for_filtered_vars(config::AbstractConfig)\n\nInitializes the model's filtered tracer fields using the actual tracer fields that are assumed to have been already set. This improves the \"spin-up\" of the filter simulation  by providing a good starting point.\n\nThe initialization formula depends on the number of filter coefficients (N_coeffs):\n\nFor a single-exponential filter (N_coeffs = 0.5), only the _C1 tracer exists and is initialized.\nFor a multi-coefficient filter (N_coeffs > 0.5), both the _C and _S tracers for each coefficient are initialized.\n\nArguments\n\nmodel: The AbstractModel whose tracers are to be initialized.\nconfig: An instance of AbstractConfig with the filter parameters.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/#Quick-Start","page":"Quick start","title":"ðŸš€ Quick Start","text":"","category":"section"},{"location":"quick_start/#Offline-Filtering","page":"Quick start","title":"Offline Filtering","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Offline filtering (whereby the data is processed after simulation time) allows for better filter shapes, since for a given reference time, data from the past and the future is available. The filters implemented here have real frequency response, and therefore have linear phase shift. If the exact properties of the filter shape are important, then offline filtering is preferable. ","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Here is a simple example of how to filter a pre-existing dataset.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using OceananigansLagrangianFilter\nusing Oceananigans.Units\nusing CUDA\n\n# Define the filter configuration\nfilter_config = OfflineFilterConfig(original_data_filename = \"my_simulation.jld2\", # Where the original simulation output is\n                                    output_filename = \"my_filtered_simulation.jld2\" # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for Lagrangian filtering\n                                    architecture = GPU(), # CPU() or GPU()\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    output_netcdf = false, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison\n\n# Run the offline filter\nrun_offline_Lagrangian_filter(filter_config)\n\n# The filtered data is now saved to `my_filtered_simulation.jld2`","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can find an example of a simple simulation of geostrophic adjustment followed by offline filtering in offline_filter_geostrophic_adjustment.jl.","category":"page"},{"location":"quick_start/#Online-Filtering","page":"Quick start","title":"Online Filtering","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For online filtering, you would integrate the filter directly into your Oceananigans.jl setup, using the helper functions provided. This is explained full in Online filtering implementation, and an example is given in online_filtering_geostrophic_adjustment.jl. The filtered values are then computed as your simulation runs, avoiding the need to save data at high frequency. ","category":"page"},{"location":"theory/offline_equations/#Offline-Lagrangian-filtering-equations","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"","category":"section"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'offline' configuration of OceananigansLagrangianFilter.jl. The offline scheme runs a forward pass very similar to the online configuration, before running a backward pass through the offline data and combinging the backward and forward outputs. ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We compute the Lagrangian mean of some scalar f as","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and optionally compute","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^infty alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We consider even filter kernels composed of sums of exponentials of the absolute value of t:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\n    G(t) = sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We define a set of N weight functions, for even N. For k = 1N2 we have","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    G_Ck(t) =e^-c_ktcos d_k t \n    G_Sk(t) =e^-c_ktsin d_k t \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"For t0, we have","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and for t0","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign labelbackward_G_derivs\n    G_Ck(t) = -G_Ck(-t) = c_kG_Ck(t) + d_k G_Sk(t) \n    G_Sk(t) = -G_Sk(-t) = c_kG_Sk(t) - d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We then define a corresponding set of N filtered scalars","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\n    f_1^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"We derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk \nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"This system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0.","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"If we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define ","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"so that","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"and","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"To define perturbation equations, we set:","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"where the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"beginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk \nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_Ck\nendalign","category":"page"},{"location":"theory/offline_equations/","page":"Offline Lagrangian filtering equations","title":"Offline Lagrangian filtering equations","text":"Backward-pass equations of the same form are solved by time-reversing the velocity and field data, and changing the sign of the velocity. The final filtered field is then reconstructed by summing the forwards and backwards pass outputs at each time. ","category":"page"},{"location":"technical_comments/#Technical-comments","page":"Technical comments","title":"Technical comments","text":"","category":"section"},{"location":"technical_comments/","page":"Technical comments","title":"Technical comments","text":"The online and offline filtering both work on GPU, just make sure CUDA is installed in the environment and loaded, and set architecture = GPU()\nThe post-processing interpolation step using regrid_to_mean_position! isn't currently set up to work in domains with immersed boundaries or with more than one bounded dimension. Interpolation results might be junk near the boundary!\nFor the offline filter, saved tracers to be filtered need to be on Center grid. Velocities should be on their standard grid. \nAs with any moving average, there are endpoint effects. For the offline filter, a time window at each end of the filtered timeseries of the order of the inverse of the cutoff frequency should be excluded from any further analysis. For the online filter, this is only necessary at the beginning of the timeseries. \nThis method is not tested with open boundaries. There is a fundamental causal issue with knowing the Lagrangian mean near a boundary when part of the trajectory on which it relies is outside of the domain. There are ways to approximate the solution near the open boundary to allow the code to run, (e.g. setting an open boundary condition on the Lagrangian filtered variables) but then the near-boundary region should be discarded. ","category":"page"},{"location":"theory/online_equations/#Online-Lagrangian-filtering-equations","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"","category":"section"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This page describes the Lagrangian filtering equations for the 'online' configuration of OceananigansLagrangianFilter.jl. They are very similar to the forward pass of the offline configuration.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We directly compute the Lagrangian mean of some scalar f as","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^t G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and optionally compute","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging) can be recovered by a post-processing interpolation step using","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We consider filter kernels composed of sums of N exponentials, where N is even.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelonlinekernel\n    G(t) = begincases\n    sum_n=1^N2 e^-c_n t left( a_n cos(d_n t) + b_n sin(d_n t) right) hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We require G to be normalised such that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\n    int_-infty^infty G(s)  ds = 1\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"or equivalently, that hatG(0) = 1. This requires that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\n    sum_n=1^N2 fraca_nc_n + b_n d_nc_n^2 + d_n^2 = 1\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This normalisation is only strictly required when we define a map that computes the trajectory mean position (map_to_mean = true in OnlineFilterConfig) but we keep the requirement for now.","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We define a set of N weight functions. For k = 1N2 we have","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    G_Ck(t) = begincases\n    e^-c_k tcos d_k thspace1cm t  0 \n    0hspace1cm t leq 0\n    endcases\n    G_Sk(t) = begincases\n    e^-c_k tsin d_k t hspace1cm t  0\n    0hspace1cm t leq 0\n    endcases\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"For t0, we have","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign labelforward_G_derivs\n    G_Ck(t) = - c_kG_Ck(t) - d_k G_Sk(t) \n    G_Sk(t) = - c_kG_Sk(t) + d_k G_Ck(t) \nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We then define a corresponding set of N filtered scalars","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalignlabelforwardgdef\n    g_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)f(vb*varphi(vb*as)s) mathrmd s\n    g_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)f(vb*varphi(vb*as)s) mathrmd s\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that ","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequationlabelreconstitutefstar\n    f^*(vb*xt) = sum_n=1^N2 a_n g_Cn(vb*xt) + b_n g_Sn(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"We derive PDEs for the g_Ck and g_Sk by taking the time derivative of \\eqref{forwardgdef}:","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial g_Ckpartial t + vb*u cdot nabla g_Ck = f - c_k g_Ck - d_k g_Sk labelgCeqn\nfracpartial g_Skpartial t + vb*u cdot nabla g_Sk =  - c_k g_Sk + d_k g_Ck labelgSeqn\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"This system of equations can be solved with initial conditions g_Ck(vb*x0) = g_Sk(vb*x0)=0 (TODO add more on ICs, spin-up)","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"If we want to find barf^mathrmL, we define map functions with which to interpolate f^* to barf^mathrmL after the simulation. We define ","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck(vb*varphi(vb*at)t) = int_-infty^t G_Ck(t-s)vb*varphi(vb*as) mathrmd s\n    vb*Xi_Sk(vb*varphi(vb*at)t) = int_-infty^t G_Sk(t-s)vb*varphi(vb*as) mathrmd s\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"so that","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginequation\nvb*Xi(vb*xt) = sum_n=1^N2 a_n vb*Xi_Ck(vb*xt) + b_n vb*Xi_Sk(vb*xt)\nendequation","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial vb*Xi_Ckpartial t + vb*u cdot nabla vb*Xi_Ck = vb*x - c_k vb*Xi_Ck - d_k vb*Xi_Sk \nfracpartial vb*Xi_Skpartial t + vb*u cdot nabla vb*Xi_Sk =  - c_k vb*Xi_Sk + d_k vb*Xi_Ck\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"To define perturbation equations, we set:","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\n    vb*Xi_Ck = vb*xi_Ck + fracc_kc_k^2 + d_k^2vb*x \n    vb*Xi_Sk = vb*xi_Sk + fracd_kc_k^2 + d_k^2vb*x\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"where the coefficients of vb*x are needed because each of the filters G_Ck and G_Sk are not individually normalised over the interval -infty0. The perturbation map equations are then given by","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"beginalign\nfracpartial vb*xi_Ckpartial t + vb*u cdot nabla vb*xi_Ck = -fracc_kc_k^2 + d_k^2vb*u - c_k vb*xi_Ck - d_k vb*xi_Sk labelxiCeqn\nfracpartial vb*xi_Skpartial t + vb*u cdot nabla vb*xi_Sk = -fracd_kc_k^2 + d_k^2vb*u - c_k vb*xi_Sk + d_k vb*xi_CklabelxiSeqn\nendalign","category":"page"},{"location":"theory/online_equations/","page":"Online Lagrangian filtering equations","title":"Online Lagrangian filtering equations","text":"and solved with initial conditions vb*xi_Ck(vb*x0) = vb*xi_Sk(vb*x0)=0.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Geostrophic-adjustment-with-offline-Lagrangian-filtering","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment with offline Lagrangian filtering","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"We set up a geostrophic adjustment problem similar to Blumen (2000), JPO in a domain that is horizontally periodic.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"An initially unbalanced two-dimensional front oscillates with the inertial frequency around a state of geostrophic balance, and we illustrate that we can remove the oscillations to find the mean state. Credit to Tom Cummings for work on this example.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"In this example, the filtering is performed offline after the simulation.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-the-simulation","page":"Geostrophic adjustment offline","title":"Run the simulation","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/#Install-dependencies","page":"Geostrophic adjustment offline","title":"Install dependencies","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"using Oceananigans\nusing Oceananigans.Units\nusing NCDatasets\nusing Printf","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Model-parameters","page":"Geostrophic adjustment offline","title":"Model parameters","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Nx = 400\nNz = 80\nf = 1e-4                # Coriolis frequency [sâ»Â¹]\nL_front = 10kilometers  # Initial front width [m]\naspect_ratio = 100      # L_front/H\nRo = 0.1                # Rossby number (defines M^2)\n\nH = L_front/aspect_ratio  # Depth\nMÂ² = (Ro^2*f^2*L_front)/H # Horizontal buoyancy gradient\nÎ”b = MÂ²*L_front # Buoyancy difference across the front\nÎºh = 1e-6 # Horizontal diffusivity\nÎºv = 1e-6 # Vertical diffusivity\n\nfilename_stem = \"geostrophic_adjustment\";","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-grid","page":"Geostrophic adjustment offline","title":"Define the grid","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"grid = RectilinearGrid(CPU(),size = (Nx, Nz),\n                       x = (-L_front/2, L_front/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Closures","page":"Geostrophic adjustment offline","title":"Closures","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"horizontal_closure = HorizontalScalarDiffusivity(Î½=Îºh, Îº=Îºh )\nvertical_closure = VerticalScalarDiffusivity(Î½=Îºv , Îº=Îºv )\nclosure = (horizontal_closure, vertical_closure);","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Tracers","page":"Geostrophic adjustment offline","title":"Tracers","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"tracers = (:b,:T)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"(:b, :T)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-model","page":"Geostrophic adjustment offline","title":"Define the model","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"model =  NonhydrostaticModel(; grid,\n                coriolis = FPlane(f = f),\n                buoyancy = BuoyancyTracer(),\n                tracers = tracers,\n                advection = WENO(),\n                closure = closure)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (b, T)\nâ”œâ”€â”€ closure: Tuple with 2 closures:\nâ”‚   â”œâ”€â”€ HorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b=1.0e-6, T=1.0e-6))\nâ”‚   â””â”€â”€ VerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b=1.0e-6, T=1.0e-6))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Initialise-the-buoyancy-and-tracer","page":"Geostrophic adjustment offline","title":"Initialise the buoyancy and tracer","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"báµ¢(x, z) = Î”b*sin(2*pi/L_front * x)\nTáµ¢(x, z) = exp(-(x/(L_front/50)).^2)\nset!(model, b= báµ¢, T= Táµ¢)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Define-the-simulation","page":"Geostrophic adjustment offline","title":"Define the simulation","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"simulation = Simulation(model, Î”t=20minutes, stop_time=3days)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 20 minutes\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 3 days\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Set an adaptive timestep","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"conjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Î”t=20minutes)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Add a progress callback","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"wall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Î”t))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(50))","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Set-up-the-output","page":"Geostrophic adjustment offline","title":"Set up the output","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"u, v, w = model.velocities\nb = model.tracers.b\nT = model.tracers.T","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"400Ã—1Ã—80 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ””â”€â”€ data: 406Ã—1Ã—86 OffsetArray(::Array{Float64, 3}, -2:403, 1:1, -2:83) with eltype Float64 with indices -2:403Ã—1:1Ã—-2:83\n    â””â”€â”€ max=0.996101, min=8.34493e-271, mean=0.0354491","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Fields to be filtered must be specified at cell centers, so we can interpolate before output if necessary.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"wc = Field(@at (Center, Center, Center) model.velocities.w)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"400Ã—1Ã—80 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: Nothing\nâ”œâ”€â”€ operand: UnaryOperation at (Center, Center, Center)\nâ”œâ”€â”€ status: time=0.0\nâ””â”€â”€ data: 406Ã—1Ã—86 OffsetArray(::Array{Float64, 3}, -2:403, 1:1, -2:83) with eltype Float64 with indices -2:403Ã—1:1Ã—-2:83\n    â””â”€â”€ max=0.0, min=0.0, mean=0.0","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Output a jld2 file for Lagrangian filtering","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"simulation.output_writers[:jld2fields] = JLD2Writer(\n    model, (; b, u, v, w, wc, T), filename = filename_stem * \".jld2\", schedule=TimeInterval(1hour), overwrite_existing=true)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"JLD2Writer scheduled on TimeInterval(1 hour):\nâ”œâ”€â”€ filepath: geostrophic_adjustment.jld2\nâ”œâ”€â”€ 6 outputs: (b, u, v, w, wc, T)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 56.2 KiB","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-simulation","page":"Geostrophic adjustment offline","title":"Run simulation","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 11.125 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Î”t: 20 minutes\n[ Info:     ... simulation initialization complete (4.683 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (2.693 seconds).\n[15.28%] i: 50, t: 11 hours, wall time: 6.623 seconds, max(u): (2.202e-02, 5.270e-02, 3.914e-04) m/s, next Î”t: 6.203 minutes\n[19.31%] i: 100, t: 13.906 hours, wall time: 2.897 seconds, max(u): (2.976e-02, 2.367e-02, 5.020e-04) m/s, next Î”t: 2.799 minutes\n[22.61%] i: 150, t: 16.282 hours, wall time: 2.870 seconds, max(u): (1.443e-02, 3.788e-03, 1.988e-04) m/s, next Î”t: 3.387 minutes\n[26.86%] i: 200, t: 19.342 hours, wall time: 2.857 seconds, max(u): (1.883e-02, 6.605e-03, 3.550e-04) m/s, next Î”t: 4.424 minutes\n[30.74%] i: 250, t: 22.136 hours, wall time: 2.828 seconds, max(u): (3.056e-02, 3.361e-02, 5.440e-04) m/s, next Î”t: 2.719 minutes\n[34.05%] i: 300, t: 1.021 days, wall time: 2.816 seconds, max(u): (1.847e-02, 5.559e-02, 3.703e-04) m/s, next Î”t: 3.396 minutes\n[38.17%] i: 350, t: 1.145 days, wall time: 2.774 seconds, max(u): (1.436e-02, 5.909e-02, 2.754e-04) m/s, next Î”t: 4.109 minutes\n[42.29%] i: 400, t: 1.269 days, wall time: 2.798 seconds, max(u): (3.040e-02, 3.490e-02, 6.369e-04) m/s, next Î”t: 2.741 minutes\n[45.41%] i: 450, t: 1.362 days, wall time: 2.805 seconds, max(u): (2.389e-02, 1.206e-02, 4.217e-04) m/s, next Î”t: 3.066 minutes\n[49.30%] i: 500, t: 1.479 days, wall time: 2.785 seconds, max(u): (8.215e-03, 3.499e-03, 2.378e-04) m/s, next Î”t: 4.080 minutes\n[53.78%] i: 550, t: 1.613 days, wall time: 2.782 seconds, max(u): (2.956e-02, 2.332e-02, 6.352e-04) m/s, next Î”t: 3.000 minutes\n[56.94%] i: 600, t: 1.708 days, wall time: 2.782 seconds, max(u): (2.593e-02, 4.716e-02, 6.036e-04) m/s, next Î”t: 3.090 minutes\n[60.67%] i: 650, t: 1.820 days, wall time: 2.786 seconds, max(u): (5.640e-03, 6.133e-02, 1.907e-04) m/s, next Î”t: 3.739 minutes\n[65.26%] i: 700, t: 1.958 days, wall time: 2.784 seconds, max(u): (2.763e-02, 4.474e-02, 7.847e-04) m/s, next Î”t: 3.016 minutes\n[68.51%] i: 750, t: 2.055 days, wall time: 2.770 seconds, max(u): (2.822e-02, 2.023e-02, 7.024e-04) m/s, next Î”t: 2.816 minutes\n[72.10%] i: 800, t: 2.163 days, wall time: 2.784 seconds, max(u): (9.688e-03, 5.764e-03, 1.411e-04) m/s, next Î”t: 3.748 minutes\n[76.39%] i: 850, t: 2.292 days, wall time: 2.782 seconds, max(u): (2.331e-02, 1.106e-02, 7.186e-04) m/s, next Î”t: 4.325 minutes\n[80.00%] i: 900, t: 2.400 days, wall time: 2.760 seconds, max(u): (2.951e-02, 3.757e-02, 8.395e-04) m/s, next Î”t: 2.823 minutes\n[83.33%] i: 950, t: 2.500 days, wall time: 2.759 seconds, max(u): (1.441e-02, 5.763e-02, 6.270e-04) m/s, next Î”t: 3.416 minutes\n[87.69%] i: 1000, t: 2.631 days, wall time: 2.797 seconds, max(u): (1.940e-02, 5.540e-02, 7.213e-04) m/s, next Î”t: 4.296 minutes\n[91.63%] i: 1050, t: 2.749 days, wall time: 2.775 seconds, max(u): (3.001e-02, 2.887e-02, 1.111e-03) m/s, next Î”t: 2.780 minutes\n[94.88%] i: 1100, t: 2.846 days, wall time: 2.761 seconds, max(u): (1.840e-02, 7.795e-03, 4.583e-04) m/s, next Î”t: 3.430 minutes\n[99.00%] i: 1150, t: 2.970 days, wall time: 2.783 seconds, max(u): (1.410e-02, 8.924e-03, 7.666e-04) m/s, next Î”t: 4.151 minutes\n[ Info: Simulation is stopping after running for 1.206 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation completed in 1.207 minutes\n","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Perform-Lagrangian-filtering","page":"Geostrophic adjustment offline","title":"Perform Lagrangian filtering","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Now we set up and run the offline Lagrangian filter on the output of the above simulation. This could be performed in a different script (with appropriate import of Oceananigans.Units and CUDA if needed)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"using OceananigansLagrangianFilter","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Set-up-the-filter-configuration","page":"Geostrophic adjustment offline","title":"Set up the filter configuration","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"filter_config = OfflineFilterConfig(original_data_filename=\"geostrophic_adjustment.jld2\", # Where the original simulation output is\n                                    output_filename = \"geostrophic_adjustment_offline_filtered.jld2\", # Where to save the filtered output\n                                    var_names_to_filter = (\"T\", \"b\"), # Which variables to filter\n                                    velocity_names = (\"u\",\"w\",\"v\"), # Velocities to use for remapping\n                                    architecture = CPU(), # CPU() or GPU(), if GPU() make sure you have CUDA.jl installed and imported\n                                    Î”t = 20minutes, # Time step of filtering simulation\n                                    T_out = 1hour, # How often to output filtered data\n                                    N = 2, # Order of Butterworth filter\n                                    freq_c = 1e-4/2, #Â Cut-off frequency of Butterworth filter\n                                    compute_mean_velocities = true, # Whether to compute the mean velocities\n                                    output_netcdf = true, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"OfflineFilterConfig(\"geostrophic_adjustment.jld2\", (\"T\", \"b\"), (\"u\", \"w\", \"v\"), 0.0, 259200.0, 259200.0, CPU(), 3600.0, (a1 = 1.767766952966369e-5, b1 = 1.767766952966369e-5, c1 = 3.535533905932738e-5, d1 = 3.535533905932738e-5, N_coeffs = 1), 1200.0, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"geostrophic_adjustment_offline_filtered.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=4), 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25, \"offline\")","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Run-the-offline-Lagrangian-filter","page":"Geostrophic adjustment offline","title":"Run the offline Lagrangian filter","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"run_offline_Lagrangian_filter(filter_config)","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"[ Info: Loaded data from geostrophic_adjustment.jld2\n[ Info: Created original variables: (:T, :b)\n[ Info: Created filtered variables: (:T_C1, :b_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :T_S1, :b_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1)\n[ Info: Created forcing for filtered variables\n[ Info: Created model\n[ Info: Initialised filtered variables\n[ Info: Defined outputs\n[ Info: Defined simulation\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (36.719 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (25.132 seconds).\n[ Info: Simulation time: 7.200 hours\n[ Info: Simulation time: 14.400 hours\n[ Info: Simulation time: 21.600 hours\n[ Info: Simulation time: 1.200 days\n[ Info: Simulation time: 1.500 days\n[ Info: Simulation time: 1.800 days\n[ Info: Simulation time: 2.100 days\n[ Info: Simulation time: 2.400 days\n[ Info: Simulation time: 2.700 days\n[ Info: Simulation is stopping after running for 14.392 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation time: 3 days\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (1.275 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (4.853 seconds).\n[ Info: Simulation time: 7.200 hours\n[ Info: Simulation time: 14.400 hours\n[ Info: Simulation time: 21.600 hours\n[ Info: Simulation time: 1.200 days\n[ Info: Simulation time: 1.500 days\n[ Info: Simulation time: 1.800 days\n[ Info: Simulation time: 2.100 days\n[ Info: Simulation time: 2.400 days\n[ Info: Simulation time: 2.700 days\n[ Info: Simulation is stopping after running for 13.580 minutes.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation time: 3 days\n[ Info: Combined forward and backward contributions into geostrophic_adjustment_offline_filtered.jld2\n[ Info: Assuming velocities normal to z boundaries are zero\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file geostrophic_adjustment_offline_filtered.jld2\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable b\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable w\n[ Info: Computing Eulerian filter for variable v\n[ Info: Wrote NetCDF file to geostrophic_adjustment_offline_filtered.nc\n","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/#Visualisation","page":"Geostrophic adjustment offline","title":"Visualisation","text":"","category":"section"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"using CairoMakie","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Now we animate the results. First, the buoyancy:","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"b\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"b_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-1e-4, 1e-4))\n\n\ntitle = @lift \"Buoyancy, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_buoyancy_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"\"geostrophic_adjustment_filtered_buoyancy_movie_offline.mp4\"","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"(Image: )","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Then the tracer:","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer concentration, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_tracer_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"\"geostrophic_adjustment_filtered_tracer_movie_offline.mp4\"","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"(Image: )","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"We see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"Then the velocity into the page, v:","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"v\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"v_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-0.05, 0.05))\n\n\ntitle = @lift \"Velocity v, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_v_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"\"geostrophic_adjustment_filtered_v_movie_offline.mp4\"","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"(Image: )","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"In this case, the Lagrangian filtered velocity fields differ from the raw fields, as expected, since velocity is not a conservative field.","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"We remove these files to keep things tidy, keep them for analysis if desired","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"rm(filename_stem * \".jld2\")\nrm(filter_config.output_filename)\nrm(filter_config.output_filename[1:end-5] * \".nc\")","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"","category":"page"},{"location":"literated/offline_filter_geostrophic_adjustment/","page":"Geostrophic adjustment offline","title":"Geostrophic adjustment offline","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Geostrophic-adjustment-with-online-Lagrangian-filtering","page":"Geostrophic adjustment online","title":"Geostrophic adjustment with online Lagrangian filtering","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"We set up a geostrophic adjustment problem similar to Blumen (2000), JPO in a domain that is horizontally periodic.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"An initially unbalanced two-dimensional front oscillates with the inertial frequency around a state of geostrophic balance, and we illustrate that we can remove the oscillations to find the mean state. Thanks to Tom Cummings for work on this example.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"In this example, the filtering is performed online during the simulation.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Load-dependencies","page":"Geostrophic adjustment online","title":"Load dependencies","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"using OceananigansLagrangianFilter # Gives access to all Oceananigans functions too\nusing Oceananigans.Units\nusing NCDatasets\nusing Printf","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Model-parameters","page":"Geostrophic adjustment online","title":"Model parameters","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Nx = 400\nNz = 80\nf = 1e-4                # Coriolis frequency [sâ»Â¹]\nL_front = 10kilometers  # Initial front width [m]\naspect_ratio = 100      # L_front/H\nRo = 0.1                # Rossby number (defines M^2)\n\n\nH = L_front/aspect_ratio  # Depth\nMÂ² = (Ro^2*f^2*L_front)/H # Horizontal buoyancy gradient\nÎ”b = MÂ²*L_front # Buoyancy difference across the front\nÎºh = 1e-6 # Horizontal diffusivity\nÎºv = 1e-6 # Vertical diffusivity\n\nfilename_stem = \"geostrophic_adjustment_online_filtered\";","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Grid","page":"Geostrophic adjustment online","title":"Grid","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"grid = RectilinearGrid(CPU(),size = (Nx, Nz),\n                       x = (-L_front/2, L_front/2),\n                       z = (-H, 0),\n                       topology = (Periodic, Flat, Bounded))","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-model-tracers","page":"Geostrophic adjustment online","title":"Define model tracers","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"tracers = (:b,:T);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-model-forcing","page":"Geostrophic adjustment online","title":"Define model forcing","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"forcing = NamedTuple();","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-filter-configuration","page":"Geostrophic adjustment online","title":"Define filter configuration","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"filter_config = OnlineFilterConfig( grid = grid,\n                                    output_filename = filename_stem * \".jld2\",\n                                    var_names_to_filter = (\"b\",\"T\"),\n                                    velocity_names = (\"u\",\"w\",\"v\"),\n                                    N = 2,\n                                    freq_c = f/2)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"OnlineFilterConfig(400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ Periodic x âˆˆ [-5000.0, 5000.0) regularly spaced with Î”x=25.0\nâ”œâ”€â”€ Flat y                         \nâ””â”€â”€ Bounded  z âˆˆ [-100.0, 0.0]     regularly spaced with Î”z=1.25, \"geostrophic_adjustment_online_filtered.jld2\", (\"b\", \"T\"), (\"u\", \"w\", \"v\"), (a1 = 1.421067568548072e-20, b1 = -7.071067811865475e-5, c1 = 3.535533905932738e-5, d1 = -3.535533905932738e-5, N_coeffs = 1), true, true, 5, \"online\")","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Create-the-filtered-variables-these-will-be-tracers-in-the-model","page":"Geostrophic adjustment online","title":"Create the filtered variables - these will be tracers in the model","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"filtered_vars = create_filtered_vars(filter_config)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"(:b_C1, :T_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :b_S1, :T_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-to-the-existing-tracers","page":"Geostrophic adjustment online","title":"Add to the existing tracers","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"tracers = (filtered_vars..., tracers...)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"(:b_C1, :T_C1, :xi_u_C1, :xi_w_C1, :xi_v_C1, :b_S1, :T_S1, :xi_u_S1, :xi_w_S1, :xi_v_S1, :b, :T)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Create-forcing-for-these-filtered-variables","page":"Geostrophic adjustment online","title":"Create forcing for these filtered variables","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"filter_forcing = create_forcing(filtered_vars, filter_config);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-these-to-the-existing-forcing","page":"Geostrophic adjustment online","title":"Add these to the existing forcing","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"forcing = merge(forcing, filter_forcing);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-closures","page":"Geostrophic adjustment online","title":"Define closures","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"If the model uses a closure, we use a helper function to set filtered variable closures to zero (unless we set filtered variable closures to zero, the default closure will apply to all tracers).","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"zero_filtered_var_closure = zero_closure_for_filtered_vars(filter_config)\nhorizontal_closure = HorizontalScalarDiffusivity(Î½=Îºh, Îº=merge((T=Îºh, b= Îºh),zero_filtered_var_closure) )\nvertical_closure = VerticalScalarDiffusivity(Î½=Îºv , Îº=merge((T=Îºv, b= Îºv),zero_filtered_var_closure) )\nclosure = (horizontal_closure, vertical_closure);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-the-model","page":"Geostrophic adjustment online","title":"Define the model","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"model =  NonhydrostaticModel(; grid,\n                coriolis = FPlane(f = f),\n                buoyancy = BuoyancyTracer(),\n                tracers = tracers,\n                forcing = forcing,\n                advection = WENO(),\n                closure = closure)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ grid: 400Ã—1Ã—80 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3Ã—0Ã—3 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (b_C1, T_C1, xi_u_C1, xi_w_C1, xi_v_C1, b_S1, T_S1, xi_u_S1, xi_w_S1, xi_v_S1, b, T)\nâ”œâ”€â”€ closure: Tuple with 2 closures:\nâ”‚   â”œâ”€â”€ HorizontalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b_C1=0.0, T_C1=0.0, xi_u_C1=0.0, xi_w_C1=0.0, xi_v_C1=0.0, b_S1=0.0, T_S1=0.0, xi_u_S1=0.0, xi_w_S1=0.0, xi_v_S1=0.0, b=1.0e-6, T=1.0e-6))\nâ”‚   â””â”€â”€ VerticalScalarDiffusivity{ExplicitTimeDiscretization}(Î½=1.0e-6, Îº=(b_C1=0.0, T_C1=0.0, xi_u_C1=0.0, xi_w_C1=0.0, xi_v_C1=0.0, b_S1=0.0, T_S1=0.0, xi_u_S1=0.0, xi_w_S1=0.0, xi_v_S1=0.0, b=1.0e-6, T=1.0e-6))\nâ”œâ”€â”€ buoyancy: BuoyancyTracer with gÌ‚ = NegativeZDirection()\nâ””â”€â”€ coriolis: FPlane{Float64}(f=0.0001)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Initialise-tracers","page":"Geostrophic adjustment online","title":"Initialise tracers","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Model buoyancy and tracers","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"báµ¢(x, z) = Î”b*sin(2*pi/L_front * x)\nTáµ¢(x, z) = exp(-(x/(L_front/50)).^2)\nset!(model, b= báµ¢, T= Táµ¢)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Set appropriate initial conditions for the filtered variables based on the actual variables","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"initialise_filtered_vars_from_model(model, filter_config)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Define-the-simulation","page":"Geostrophic adjustment online","title":"Define the simulation","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"simulation = Simulation(model, Î”t=20minutes, stop_time=3days)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\nâ”œâ”€â”€ Next time step: 20 minutes\nâ”œâ”€â”€ Elapsed wall time: 0 seconds\nâ”œâ”€â”€ Wall time per iteration: NaN days\nâ”œâ”€â”€ Stop time: 3 days\nâ”œâ”€â”€ Stop iteration: Inf\nâ”œâ”€â”€ Wall time limit: Inf\nâ”œâ”€â”€ Minimum relative step: 0.0\nâ”œâ”€â”€ Callbacks: OrderedDict with 4 entries:\nâ”‚   â”œâ”€â”€ stop_time_exceeded => 4\nâ”‚   â”œâ”€â”€ stop_iteration_exceeded => -\nâ”‚   â”œâ”€â”€ wall_time_limit_exceeded => e\nâ”‚   â””â”€â”€ nan_checker => }\nâ”œâ”€â”€ Output writers: OrderedDict with no entries\nâ””â”€â”€ Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Set-an-adaptive-timestep","page":"Geostrophic adjustment online","title":"Set an adaptive timestep","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"conjure_time_step_wizard!(simulation, IterationInterval(20), cfl=0.2, max_Î”t=20minutes)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Add-a-progress-callback","page":"Geostrophic adjustment online","title":"Add a progress callback","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"wall_clock = Ref(time_ns())\n\nfunction print_progress(sim)\n    u, v, w = model.velocities\n    progress = 100 * (time(sim) / sim.stop_time)\n    elapsed = (time_ns() - wall_clock[]) / 1e9\n\n    @printf(\"[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Î”t: %s\\n\",\n            progress, iteration(sim), prettytime(sim), prettytime(elapsed),\n            maximum(abs, u), maximum(abs, v), maximum(abs, w), prettytime(sim.Î”t))\n\n    wall_clock[] = time_ns()\n\n    return nothing\nend\n\nadd_callback!(simulation, print_progress, IterationInterval(50))","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Set-up-the-outputs","page":"Geostrophic adjustment online","title":"Set up the outputs","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Create filtered outputs:","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"outputs = create_output_fields(model, filter_config);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Add in original variables if needed:","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"outputs[\"b\"] = model.tracers.b;\noutputs[\"T\"] = model.tracers.T;\noutputs[\"u\"] = model.velocities.u;\noutputs[\"v\"] = model.velocities.v;\noutputs[\"w\"] = model.velocities.w;","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Output a .jld2 file:","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"simulation.output_writers[:jld2fields] = JLD2Writer(\n    model, outputs, filename=filter_config.output_filename, schedule=TimeInterval(1hour), overwrite_existing=true)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"JLD2Writer scheduled on TimeInterval(1 hour):\nâ”œâ”€â”€ filepath: geostrophic_adjustment_online_filtered.jld2\nâ”œâ”€â”€ 13 outputs: (xi_u, T, b, b_Lagrangian_filtered, xi_v, xi_w, v, w, v_Lagrangian_filtered, w_Lagrangian_filtered, T_Lagrangian_filtered, u, u_Lagrangian_filtered)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :buoyancy, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 92.7 KiB","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Run-the-simulation","page":"Geostrophic adjustment online","title":"Run the simulation","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"@info \"Running the simulation...\"\n\nrun!(simulation)\n\n@info \"Simulation completed in \" * prettytime(simulation.run_wall_time)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Running the simulation...\n[ Info: Initializing simulation...\n[00.00%] i: 0, t: 0 seconds, wall time: 6.750 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Î”t: 20 minutes\n[ Info:     ... simulation initialization complete (44.446 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (18.622 seconds).\n[15.28%] i: 50, t: 11 hours, wall time: 3.309 minutes, max(u): (2.202e-02, 5.270e-02, 3.914e-04) m/s, next Î”t: 6.203 minutes\n[19.31%] i: 100, t: 13.906 hours, wall time: 2.913 minutes, max(u): (2.976e-02, 2.367e-02, 5.020e-04) m/s, next Î”t: 2.799 minutes\n[22.61%] i: 150, t: 16.282 hours, wall time: 2.841 minutes, max(u): (1.443e-02, 3.788e-03, 1.988e-04) m/s, next Î”t: 3.387 minutes\n[26.86%] i: 200, t: 19.342 hours, wall time: 2.791 minutes, max(u): (1.883e-02, 6.605e-03, 3.550e-04) m/s, next Î”t: 4.424 minutes\n[30.74%] i: 250, t: 22.136 hours, wall time: 2.725 minutes, max(u): (3.056e-02, 3.361e-02, 5.440e-04) m/s, next Î”t: 2.719 minutes\n[34.05%] i: 300, t: 1.021 days, wall time: 2.809 minutes, max(u): (1.847e-02, 5.559e-02, 3.703e-04) m/s, next Î”t: 3.396 minutes\n[38.17%] i: 350, t: 1.145 days, wall time: 2.773 minutes, max(u): (1.436e-02, 5.909e-02, 2.754e-04) m/s, next Î”t: 4.109 minutes\n[42.29%] i: 400, t: 1.269 days, wall time: 2.828 minutes, max(u): (3.040e-02, 3.490e-02, 6.369e-04) m/s, next Î”t: 2.741 minutes\n[45.41%] i: 450, t: 1.362 days, wall time: 2.804 minutes, max(u): (2.389e-02, 1.206e-02, 4.217e-04) m/s, next Î”t: 3.066 minutes\n[49.30%] i: 500, t: 1.479 days, wall time: 2.743 minutes, max(u): (8.215e-03, 3.499e-03, 2.378e-04) m/s, next Î”t: 4.080 minutes\n[53.78%] i: 550, t: 1.613 days, wall time: 2.773 minutes, max(u): (2.956e-02, 2.332e-02, 6.352e-04) m/s, next Î”t: 3.000 minutes\n[56.94%] i: 600, t: 1.708 days, wall time: 2.842 minutes, max(u): (2.593e-02, 4.716e-02, 6.036e-04) m/s, next Î”t: 3.090 minutes\n[60.67%] i: 650, t: 1.820 days, wall time: 2.821 minutes, max(u): (5.640e-03, 6.133e-02, 1.907e-04) m/s, next Î”t: 3.739 minutes\n[65.26%] i: 700, t: 1.958 days, wall time: 2.789 minutes, max(u): (2.763e-02, 4.474e-02, 7.847e-04) m/s, next Î”t: 3.016 minutes\n[68.51%] i: 750, t: 2.055 days, wall time: 2.742 minutes, max(u): (2.822e-02, 2.023e-02, 7.024e-04) m/s, next Î”t: 2.816 minutes\n[72.10%] i: 800, t: 2.163 days, wall time: 2.808 minutes, max(u): (9.688e-03, 5.764e-03, 1.411e-04) m/s, next Î”t: 3.748 minutes\n[76.39%] i: 850, t: 2.292 days, wall time: 2.890 minutes, max(u): (2.331e-02, 1.106e-02, 7.186e-04) m/s, next Î”t: 4.325 minutes\n[80.00%] i: 900, t: 2.400 days, wall time: 2.891 minutes, max(u): (2.951e-02, 3.757e-02, 8.395e-04) m/s, next Î”t: 2.823 minutes\n[83.33%] i: 950, t: 2.500 days, wall time: 2.881 minutes, max(u): (1.441e-02, 5.763e-02, 6.270e-04) m/s, next Î”t: 3.416 minutes\n[87.69%] i: 1000, t: 2.631 days, wall time: 2.837 minutes, max(u): (1.940e-02, 5.540e-02, 7.213e-04) m/s, next Î”t: 4.296 minutes\n[91.63%] i: 1050, t: 2.749 days, wall time: 2.798 minutes, max(u): (3.001e-02, 2.887e-02, 1.111e-03) m/s, next Î”t: 2.780 minutes\n[94.88%] i: 1100, t: 2.846 days, wall time: 2.861 minutes, max(u): (1.840e-02, 7.795e-03, 4.583e-04) m/s, next Î”t: 3.430 minutes\n[99.00%] i: 1150, t: 2.970 days, wall time: 2.813 minutes, max(u): (1.410e-02, 8.924e-03, 7.666e-04) m/s, next Î”t: 4.151 minutes\n[ Info: Simulation is stopping after running for 1.107 hours.\n[ Info: Simulation time 3 days equals or exceeds stop time 3 days.\n[ Info: Simulation completed in 1.108 hours\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-regrid-to-mean-position","page":"Geostrophic adjustment online","title":"Option to regrid to mean position","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"if filter_config.map_to_mean\n    regrid_to_mean_position!(filter_config)\nend","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Assuming velocities normal to z boundaries are zero\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file geostrophic_adjustment_online_filtered.jld2\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-calculate-Eulerian-filter-too","page":"Geostrophic adjustment online","title":"Option to calculate Eulerian filter too","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"compute_Eulerian_filter!(filter_config);","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Computing Eulerian filter for variable b\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable w\n[ Info: Computing Eulerian filter for variable v\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-add-a-shifted-time-coordinate","page":"Geostrophic adjustment online","title":"Option to add a shifted time coordinate","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"compute_time_shift!(filter_config)","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Wrote time shift data to new group timeseries/t_shifted in file geostrophic_adjustment_online_filtered.jld2\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Option-to-output-a-final-NetCDF-file","page":"Geostrophic adjustment online","title":"Option to output a final NetCDF file","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"jld2_to_netcdf(filename_stem * \".jld2\", filename_stem * \".nc\")","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Wrote NetCDF file to geostrophic_adjustment_online_filtered.nc\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Animate-the-results,-buoyancy-first:","page":"Geostrophic adjustment online","title":"Animate the results, buoyancy first:","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"using CairoMakie\n\ntimeseries1 = FieldTimeSeries(filter_config.output_filename, \"b\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"b_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"b_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-1e-4, 1e-4))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-1e-4, 1e-4))\n\n\ntitle = @lift \"Buoyancy, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_buoyancy_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"\"geostrophic_adjustment_filtered_buoyancy_movie_online.mp4\"","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"(Image: )","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/#Then-plot-the-tracer-concentration:","page":"Geostrophic adjustment online","title":"Then plot the tracer concentration:","text":"","category":"section"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer concentration, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_tracer_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"[ Info: Making an animation\n","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"(Image: )","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"We see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures. In comparison to the offline filtering example, the online filter does a slightly worse job removing the oscillations in the 'Lagrangian filtered at mean' field, since the filter is a more optimal low-pass.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"Then the velocity into the page, v:","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"v\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"v_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"v_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"z\",\n               limits = ((-5000, 5000), (-100, 0)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered \\n at mean position\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax2, var2; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax3, var3; colormap = :balance, colorrange = (-0.05, 0.05))\nheatmap!(ax4, var4; colormap = :balance, colorrange = (-0.05, 0.05))\n\n\ntitle = @lift \"Velocity v, time = \" * string(round(times[$n]./3600., digits=2)) * \" hours\"\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"geostrophic_adjustment_filtered_v_movie_online.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"\"geostrophic_adjustment_filtered_v_movie_online.mp4\"","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"(Image: )","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"In this case, the Lagrangian filtered velocity fields differ from the raw fields, as expected, since velocity is not a conservative field.","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"#Â We remove these files to keep things tidy, keep them for analysis if desired\nrm(filename_stem * \".jld2\")\nrm(filename_stem * \".nc\")","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"","category":"page"},{"location":"literated/online_filter_geostrophic_adjustment/","page":"Geostrophic adjustment online","title":"Geostrophic adjustment online","text":"This page was generated using Literate.jl.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#Choosing-offline-filters","page":"Choosing offline filters","title":"Choosing offline filters","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"To be added. ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"Quick version: set N and freq_c in OfflineFilterConfig to get a filter with squared amplitude of a Butterworth order N filter with cutoff frequency freq_c.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"If N=1 then a double sided exponential filter is found. Otherwise, N should be even.","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#General-form","page":"Choosing offline filters","title":"General form","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Exponential","page":"Choosing offline filters","title":"Exponential","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/#Butterworth-(squared)","page":"Choosing offline filters","title":"Butterworth (squared)","text":"","category":"section"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"The filter coefficients are chosen as","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"beginalign\n    a_n = fracomega_cNsinfracpi2N(2n-1) \n    b_n = fracomega_cNcosfracpi2N(2n-1) \n    c_n = omega_csinfracpi2N(2n-1) \n    d_n = omega_ccosfracpi2N(2n-1)\nendalign","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"This choice gives a weight function G(t) with frequency response ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"beginequation\n    hatG(omega) = frac11 + left(omegaomega_cright)^2N\nendequation","category":"page"},{"location":"offline_filtering/choosing_offline_filters/","page":"Choosing offline filters","title":"Choosing offline filters","text":"which approaches a low-pass cutoff filter as N rightarrow infty. ","category":"page"},{"location":"offline_filtering/choosing_offline_filters/#Define-your-own","page":"Choosing offline filters","title":"Define your own","text":"","category":"section"},{"location":"theory/filtering_PDEs/#Background:-PDEs-for-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/#Introduction","page":"Background: PDEs for Lagrangian filtering","title":"Introduction","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Lagrangian averaging (or, equivalently, Lagrangian filtering) is an effective way to decompose complex multi-scale flows into wave and mean components, as it allows separation based on intrinsic frequency of processes, that is, frequency in the frame of the flow. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Lagrangian means are usually found by seeding virtual particles in numerical simulations and keeping track of their positions. However, various methods for calculating Lagrangian means through the solution of PDEs have recently been developed (Kafiabad and Vanneste, 2023; Baker et al., 2025; Minz et al., 2025), removing the need for particle tracking. These PDE-based methods are flexible, and allow various ways of computing the Lagrangian mean dependent on the use case. Some considerations include:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Should the filtering be performed online (at simulation time) or offline (after simulation time, using saved data)?\nHow important is the filter shape - can we get away with a less strict low-pass?\nHow often do we need to find the Lagrangian mean? Once per averaging interval, or at every time? ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"These considerations will determine how the Lagrangian average should be performed, and how OceananigansLagrangianFilter is used. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Before describing how to find Lagrangian averages with PDEs, we first describe the simpler case of finding Eulerian averages with ODEs. ","category":"page"},{"location":"theory/filtering_PDEs/#ODEs-for-Eulerian-time-averages","page":"Background: PDEs for Lagrangian filtering","title":"ODEs for Eulerian time averages","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We consider some scalar function f(t) (for now neglecting the spatial dimension), from which we would like to obtain barf, its low-pass filter. We know f only at the current simulation time t, and it can only depend on past times by causality, so we must have ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(t) = int_-infty^t K(ts) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some weight function K(ts), whose shape (a function of s) could depend on the current time t. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We look for an evolution equation of barf and take the time derivative, finding:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabeltime_evol1\n    dotbarf(t) = K(tt) f(t) + int_-infty^t fracpartialpartial tK(ts) mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"To be able to close this equation so that it only depends on information available at the current time, we need either:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"fracpartialpartial tK(ts) = alpha(t)K(ts), so that the integral in \\eqref{time_evol1} can be expressed in terms of barf.\nfracpartialpartial tK(ts) = 0, so that K(ts) equiv G(s), and the weight function G(s) does not change as t increases. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"These two options give rise to different schemes. ","category":"page"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-moving-exponential-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with moving exponential weight functions","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In this case, the most general weight function satisfies fracpartialpartial tK(ts) = alpha(t)K(ts). However, we additionally constrain the weight function by imposing that although the reference time of the weight function changes with the simulation time  t, it's shape should not, so K(ts) = G(t-s), and barf is a convolution between the impulse response G(t) and f. This then implies that ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    K(ts) equiv G(t -s) = alpha e^-alpha (t -s)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some constant alpha. With this special exponential weight function, the normalisation ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    int_-infty^t G(t - s)  ds = 1\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"holds at all times so barf describes the exponential mean at all times (after some initial spin-up), and is given by","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelexponentialODE\n    dotbarf(t) = alpha(f(t) - barf(t))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Therefore, when the weight function G(t) is exponential (or composed of a small number of exponentials, as will be descibed later) equation \\eqref{exponentialODE} can be solved alongside the governing equation for f(t) and the exponential mean found 'on-the-fly'. The methods that are currently implemented in OceananigansLagrangianFilter are based on sums of exponential weight functions.","category":"page"},{"location":"theory/filtering_PDEs/#Temporal-averaging-with-fixed-arbitrary-weight-functions","page":"Background: PDEs for Lagrangian filtering","title":"Temporal averaging with fixed arbitrary weight functions","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In this case, the weight function G(s) doesn't shift with the simulation time t, so the low pass variable","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(t) = int_-infty^t G(s) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"only truly describes the low-pass filtered field as t rightarrow infty. The weight function G(s) can take any form, but should satisfy the normalisation ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    int_-infty^infty G(s) mathrmd s = 1\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"In reality, we consider some finite interval t^* - T2 t^* + T2 for some reference time t^*, and consider","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    barf(tt^*) = int_t^* - T2^t G(t^* - s) f(s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"where barf(t^* + T2t^*) is our desired output, G(t) is only non-zero on -T2T2, and barf satisfies","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    dotbarf(tt^*) = G(t^* - t)f(t)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"We can think of t^*_i = T2 + iT, where T is the averaging interval, and i in 012 as defining a coarse time, and solve for the mean at each t^*_i by reinitialising barf after each time T so that barf(iTt^*_i) = 0.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Methods for filtering with arbitrary weight functions in this way are described in Baker et al. (2025). These are not yet implemented in OceananigansLagrangianFilter, but raise an issue on our github if you're interested in using these methods. ","category":"page"},{"location":"theory/filtering_PDEs/#Online-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Online exponential Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Here, we demonstrate the how the (single) exponential Lagrangian mean can be found online. This is the basic idea behind OceananigansLagrangianFilter, and is a simplified version of the exponential Lagrangian averaging described in (Minz et al., 2025). We define (see Lagrangian averaging for general definitions):","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelsingleexpfstar\n    f^*(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)f(vb*varphi(vb*as)s)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"for some inverse timescale alpha. Taking the time derivative of \\eqref{singleexpfstar} at fixed vb*a, and using the chain rule, gives","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    fracpartial f^*partial t(vb*varphi(vb*at)t) + fracpartial vb*varphipartial t(vb*at)cdot nabla f^*(vb*varphi(vb*at)t) = alpha(f(vb*varphi(vb*at)t) - f^*(vb*varphi(vb*at)t))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Setting vb*varphi(vb*at) = vb*x, and noting that fracpartial vb*varphipartial t (vb*at)= vb*u(vb*varphi(vb*at)t) by definition of the flow map, we have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelfstareqnsingleexp\n    fracpartial f^*partial t(vb*xt) + vb*u cdotnabla f^*(vb*xt) = alpha(f(vb*xt) - f^*(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"This equation can then be solved alongside the dynamical equations of the simulation (which will determine f and vb*u) to find f^* at all times (after some suitable spin-up period). ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"If we also want to find the generalised Lagrangian mean barf^mathrmL (see definition in Lagrangian averaging), we define a map","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelXidefonline\nvb*Xi(vb*varphi(vb*at)t) = int_-infty^t alpha e^-alpha(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Taking the time derivative, we find (c.f. \\eqref{fstareqnsingleexp})","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelXieqnsingleexp\n    fracpartial vb*Xipartial t(vb*xt) + vb*u cdotnabla vb*Xi(vb*xt) = alpha(vb*x - vb*Xi(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Defining a perturbation vb*xi(vb*xt) = vb*Xi(vb*xt) - vb*x, we then have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelxieqnsingleexp\n    fracpartial vb*xipartial t(vb*xt) + vb*u cdotnabla vb*xi(vb*xt) = - vb*u - alpha vb*Xi(vb*xt)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"After having solved \\eqref{fstareqnsingleexp} for f^* and \\eqref{xieqnsingleexp} for vb*xi, the relation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nbarf^mathrmL(vb*Xi(vb*xt)t) = f^*(vb*xt)\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"can be used to recover barf^mathrmL by interpolation.","category":"page"},{"location":"theory/filtering_PDEs/#Offline-exponential-Lagrangian-filtering","page":"Background: PDEs for Lagrangian filtering","title":"Offline exponential Lagrangian filtering","text":"","category":"section"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"While the exponential formulation is efficient as it finds the mean at all times, it limits the possible weight functions, and in particular limits us to causal averages, which depend at any time only on past data. For this reason, we also develop an approach to exponential filtering that combines a 'forward' exponential average (as in \\eqref{fstareqnsingleexp}) with a 'backward' exponential pass. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"For \\eqref{fstareqnsingleexp} to be run `backwards', the filtering must be performed offline and the data therefore saved at wave-resolving resolution. The forward and backward outputs are summed to give a total output with a more desirable effective filter shape, at the expense of the necessity of saving data. ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The goal is to find ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    f^*(vb*varphi(vb*at) t) = int_-infty^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"where G(t) is even such that G(t) equiv G(t). ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"This property means that the weight function will be centred on the reference time t, and the frequency response of this filter will be real. Such filters have linear phase shift (or, in this case, zero phase shift,* since G is symmetric about t=0). This means that the phases of frequencies in the pass-band are not modified, in contrast to filters like the single sided exponential used in Online Lagrangian filtering. See Choosing online filters for more explanation of weight functions.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"For a single exponential (as opposed to sums of exponentials, to be introduced in Online Lagrangian filtering equations and Offline Lagrangian filtering equations),","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nG(t-s) = fracalpha2 e^-alphat-s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"i.e. a `double sided exponential'.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"On the forward pass (which can be performed either 'online' at the same time as the simulation, or `offline' on saved data - our implementation does this offline since data must be saved for the backward pass anyway) we calculate","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\n    f^*_1(vb*varphi(vb*at) t) = int_-infty^t G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"and on the backward pass (which must be performed offline) we calculate ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2star\n    f^*_2(vb*varphi(vb*at) t) = int_t^infty G(t-s) f(vb*varphi(vb*as) s)  mathrmd s\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"such that f^* = f^*_1 + f^*_2.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The forward equation is identical to the online scheme \\eqref{fstareqnsingleexp}, aside from a factor of two to ensure that the normalisation of the weight function still holds:","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf1stareqnsingleexp\n    fracpartial f^*_1partial t(vb*xt) + vb*u cdotnabla f^*_1(vb*xt) = fracalpha2(f(vb*xt) - f^*_1(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"The backward equation is found by first taking the time derivative of \\eqref{f2star} to give","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp\n    fracpartial f^*_2partial t(vb*xt) + vb*u cdotnabla f^*_2(vb*xt) = -fracalpha2(f(vb*xt) - f^*(vb*xt))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"then setting tildet = T - t, where T is the total simulation time (or end of the desired averaging interval), to give","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp_timereversed\n    fracpartial f^*_2partial tildet(vb*xT - tildet) - vb*u cdotnabla f^*_2(vb*xT - tildet) = fracalpha2(f(vb*xT - tildet) - f^*(vb*xT - tildet))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Defining tildef^*_2(vb*xtildet) = f^*_2(vb*xT-tildet), tildef(vb*xtildet) = f(vb*xT-tildet), and tildevb*u(vb*xtildet) = vb*u(vb*xT-tildet), we then have","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequationlabelf2stareqnsingleexp_tilde\n    fracpartial tildef^*_2partial tildet(vb*xtildet) + tildevb*u cdotnabla tildef^*_2(vb*xtildet) = fracalpha2(f(vb*xtildet) - tildef^*(vb*xtildet))\nendequation","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"which is equivalent to \\eqref{f1stareqnsingleexp} solved backwards with negated velocities. Equations for the forward and backward maps vb*Xi_1 and vb*Xi_2 (c.f. \\eqref{Xidefonline}) can be found similarly by setting f to the identity in \\eqref{fstareqnsingleexp} and \\eqref{f2stareqnsingleexp_tilde}.","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"Having found f_1^* on the forward pass, and tildef_2^* on the backward pass, we then calculate ","category":"page"},{"location":"theory/filtering_PDEs/","page":"Background: PDEs for Lagrangian filtering","title":"Background: PDEs for Lagrangian filtering","text":"beginequation\nf^*(vb*xt) = f_1^*(vb*xt) + tildef_2^*(vb*xT-t)\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-and-Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/#Eulerian-averaging","page":"Eulerian and Lagrangian averaging","title":"Eulerian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The Eulerian weighted temporal mean of some scalar f is defined as","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\nlabelfbarEdef\n    barf^mathrmE(vb*xt) = int_-infty^infty G(t-s)f(vb*xs)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"where G(t) is some weight function, also referred to as a filter kernel or impulse response. The Fourier transform of G(t) is denoted hatG(omega), and is the frequency response of the weight function. Here, we will generally want G(t) to represent a low-pass filter, which retains the low frequencies and removes high frequencies. For example, two possible choices of weight function are ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"Top-hat impulse response: G(t) = begincases 1T  hspace1cm -T2  t  T2  0 hspace1cm mathrmotherwiseendcases\nTop-hat frequency response:  hatG(omega) = begincases 1  hspace1cm -omega_c  omega  omega_c  0 hspace1cm mathrmotherwiseendcases","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The Eulerian mean barf^mathrmE(vb*xt) is the field found by taking an average in time at a fixed spatial location vb*x. ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/#Lagrangian-averaging","page":"Eulerian and Lagrangian averaging","title":"Lagrangian averaging","text":"","category":"section"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"In contrast, the Lagrangian mean finds the temporal average whilst moving with the flow on an (imaginary) fluid particle. We define the Lagrangian weighted temporal mean as ","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\nlabelfbardef\n    barf^mathrmL(barvb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"where the flow map  vb*varphi(vb*at) is the position at time t of a particle with label vb*a (which could be the initial position of the particle such that vb*varphi(vb*a0) = vb*a). The mean flow map barvb*varphi is defined by","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequationlabelphibardef\nbarvb*varphi(vb*a t) = int_-infty^infty G(t-s)vb*varphi(vb*as)mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"The definition \\eqref{fbardef} ensures that barf^mathrmL is the true generalised Lagrangian mean, in that (for strict band-pass filters) applying the same averaging procedure to the mean flow itself leaves it unchanged (Baker et al., 2025). However, we also define an alternative Lagrangian mean, which is a rearrangement of barf^mathrmL:","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequationlabelfstardef\n    f^*(vb*varphi(vb*at)t) = int_-infty^infty G(t-s)f(vb*varphi(vb*as)s)  mathrmd s\nendequation","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"While barf^mathrmL(vb*xt) describes the average along a particle trajectory whose mean position is vb*x, f^*(vb*xt) defines the average along a particle trajectory whose position is vb*x at time t. It is often more desirable, or more convenient, to find f^* instead. If barf^mathrmL is also needed, it can be found by a rearrangement of f^* using a map","category":"page"},{"location":"theory/Eulerian_Lagrangian_definitions/","page":"Eulerian and Lagrangian averaging","title":"Eulerian and Lagrangian averaging","text":"beginequation\n    vb*Xi(vb*varphi(vb*at)t) = barvb*varphi(vb*at)\nendequation","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Shallow-water-intertial-oscillations-with-offline-Lagrangian-filtering","page":"Shallow water inertial oscillation offline","title":"Shallow water intertial oscillations with offline Lagrangian filtering","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"This example demonstrates how to perform offline filtering on a shallow water simulation to remove the effect of inertial oscillations on a tracer field.","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"We could also filter a shallow water simulation online, but would have to use the VectorInvariantFormulation in order to have direct access to the model velocities. This example uses the ConservativeFormulation instead, and filtering is performed offline using the saved velocities after they have been calculated from uh and vh.","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Run-the-simulation","page":"Shallow water inertial oscillation offline","title":"Run the simulation","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/#Install-dependencies","page":"Shallow water inertial oscillation offline","title":"Install dependencies","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"using Oceananigans\nusing Printf\nusing NCDatasets\n\nfilename_stem = \"SW_IO_with_tracer\";","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Define-the-grid","page":"Shallow water inertial oscillation offline","title":"Define the grid","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"grid = RectilinearGrid(CPU(), size = (50, 50),\n                       x = (0, 2*pi),\n                       y = (0, 2*pi),\n                       topology = (Periodic, Periodic, Flat))","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”x=0.125664\nâ”œâ”€â”€ Periodic y âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”y=0.125664\nâ””â”€â”€ Flat z                              ","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Set-parameters","page":"Shallow water inertial oscillation offline","title":"Set parameters","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Building a ShallowWaterModel. We non-dimensionalise as in Kafiabad & Vanneste 2023.","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Fr = 0.1 # Froude number\nRo = 1 # fRossby number\n\ngravitational_acceleration = 1/Fr^2\ncoriolis = FPlane(f=1/Ro)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"FPlane{Float64}(f=1.0)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Define-the-model","page":"Shallow water inertial oscillation offline","title":"Define the model","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,\n                            timestepper = :RungeKutta3,\n                            tracers= (:T,),\n                            momentum_advection = WENO())","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) \nâ”œâ”€â”€ grid: 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ timestepper: RungeKutta3TimeStepper\nâ”œâ”€â”€ advection scheme: \nâ”‚   â”œâ”€â”€ momentum: WENO{3, Float64, Float32}(order=5)\nâ”‚   â”œâ”€â”€ mass: WENO{3, Float64, Float32}(order=5)\nâ”‚   â””â”€â”€ T: WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ tracers: (:T,)\nâ””â”€â”€ coriolis: FPlane{Float64}","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Initial-conditions","page":"Shallow water inertial oscillation offline","title":"Initial conditions","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Velocity and height initial conditions - uniform velocity perturbation, initial height is 1 (unperturbed)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"displacement = 2*pi/10\nu_i = displacement/Ro\nh_i = 1\nuh_i = u_i*h_i;","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Initialise a tracer as a blob in the middle of the domain","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"width = 2*pi/15\nT_i(x, y) = exp(-(((x - pi)^2 + (y - pi)^2)/width).^2)\n\nset!(model, uh = uh_i, h= h_i, T = T_i )\n\nuh, vh, h = model.solution\n\nu = Field(uh / h)\nv = Field(vh / h)\nT = model.tracers.T","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"50Ã—50Ã—1 Field{Center, Center, Center} on RectilinearGrid on CPU\nâ”œâ”€â”€ grid: 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ boundary conditions: FieldBoundaryConditions\nâ”‚   â””â”€â”€ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: Nothing\nâ””â”€â”€ data: 56Ã—56Ã—1 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, 1:1) with eltype Float64 with indices -2:53Ã—-2:53Ã—1:1\n    â””â”€â”€ max=0.999645, min=0.0, mean=0.0295409","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Simulation","page":"Shallow water inertial oscillation offline","title":"Simulation","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"simulation = Simulation(model, Î”t = 1e-2, stop_time = 20)\n\nfunction progress(sim)\n    model = sim.model\n    uh, vh, h = model.solution\n    @info @sprintf(\"Simulation time: %s, max(|uh|, |vh|, |h|): %.2e, %.2e, %.2e \\n\",\n                   prettytime(sim.model.clock.time),\n                   maximum(abs, uh), maximum(abs, vh),\n                   maximum(abs, h))\n\n    return nothing\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Callback of progress on IterationInterval(100)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Set-up-the-outputs","page":"Shallow water inertial oscillation offline","title":"Set up the outputs","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Save velocities and tracer for Lagrangian filtering","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"simulation.output_writers[:fields_jld2] = JLD2Writer(model, (; u,v,T),\n                                                        filename = filename_stem * \".jld2\",\n                                                        schedule = TimeInterval(0.1),\n                                                        overwrite_existing = true)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"JLD2Writer scheduled on TimeInterval(100 ms):\nâ”œâ”€â”€ filepath: SW_IO_with_tracer.jld2\nâ”œâ”€â”€ 3 outputs: (u, v, T)\nâ”œâ”€â”€ array_type: Array{Float32}\nâ”œâ”€â”€ including: [:grid, :coriolis, :closure]\nâ”œâ”€â”€ file_splitting: NoFileSplitting\nâ””â”€â”€ file size: 30.2 KiB","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#And-finally-run-the-simulation.","page":"Shallow water inertial oscillation offline","title":"And finally run the simulation.","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"run!(simulation)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds, max(|uh|, |vh|, |h|): 6.28e-01, 0.00e+00, 1.00e+00 \n[ Info:     ... simulation initialization complete (6.773 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (5.210 seconds).\n[ Info: Simulation time: 930.000 ms, max(|uh|, |vh|, |h|): 3.76e-01, 5.04e-01, 1.00e+00 \n[ Info: Simulation time: 1.890 seconds, max(|uh|, |vh|, |h|): 1.97e-01, 5.97e-01, 1.00e+00 \n[ Info: Simulation time: 2.800 seconds, max(|uh|, |vh|, |h|): 5.92e-01, 2.10e-01, 1.00e+00 \n[ Info: Simulation time: 3.710 seconds, max(|uh|, |vh|, |h|): 5.30e-01, 3.38e-01, 1.00e+00 \n[ Info: Simulation time: 4.620 seconds, max(|uh|, |vh|, |h|): 5.80e-02, 6.26e-01, 1.00e+00 \n[ Info: Simulation time: 5.530 seconds, max(|uh|, |vh|, |h|): 4.58e-01, 4.30e-01, 1.00e+00 \n[ Info: Simulation time: 6.440 seconds, max(|uh|, |vh|, |h|): 6.21e-01, 9.81e-02, 1.00e+00 \n[ Info: Simulation time: 7.350 seconds, max(|uh|, |vh|, |h|): 3.03e-01, 5.50e-01, 1.00e+00 \n[ Info: Simulation time: 8.260 seconds, max(|uh|, |vh|, |h|): 2.48e-01, 5.77e-01, 1.00e+00 \n[ Info: Simulation time: 9.170 seconds, max(|uh|, |vh|, |h|): 6.08e-01, 1.58e-01, 1.00e+00 \n[ Info: Simulation time: 10.080 seconds, max(|uh|, |vh|, |h|): 4.98e-01, 3.83e-01, 1.00e+00 \n[ Info: Simulation time: 10.990 seconds, max(|uh|, |vh|, |h|): 3.50e-03, 6.28e-01, 1.00e+00 \n[ Info: Simulation time: 11.900 seconds, max(|uh|, |vh|, |h|): 4.94e-01, 3.88e-01, 1.00e+00 \n[ Info: Simulation time: 12.800 seconds, max(|uh|, |vh|, |h|): 6.11e-01, 1.45e-01, 1.00e+00 \n[ Info: Simulation time: 13.710 seconds, max(|uh|, |vh|, |h|): 2.60e-01, 5.72e-01, 1.00e+00 \n[ Info: Simulation time: 14.620 seconds, max(|uh|, |vh|, |h|): 2.92e-01, 5.56e-01, 1.00e+00 \n[ Info: Simulation time: 15.530 seconds, max(|uh|, |vh|, |h|): 6.18e-01, 1.11e-01, 1.00e+00 \n[ Info: Simulation time: 16.480 seconds, max(|uh|, |vh|, |h|): 4.50e-01, 4.38e-01, 1.00e+00 \n[ Info: Simulation time: 17.480 seconds, max(|uh|, |vh|, |h|): 1.26e-01, 6.16e-01, 1.00e+00 \n[ Info: Simulation time: 18.480 seconds, max(|uh|, |vh|, |h|): 5.86e-01, 2.27e-01, 1.00e+00 \n[ Info: Simulation time: 19.480 seconds, max(|uh|, |vh|, |h|): 5.08e-01, 3.70e-01, 1.00e+00 \n[ Info: Simulation is stopping after running for 19.304 seconds.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Perform-Lagrangian-filtering","page":"Shallow water inertial oscillation offline","title":"Perform Lagrangian filtering","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Now we set up and run the offline Lagrangian filter on the output of the above simulation. This could be performed in a different script (with appropriate import of Oceananigans.Units and CUDA if needed)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"using OceananigansLagrangianFilter","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Set-up-the-filter-configuration","page":"Shallow water inertial oscillation offline","title":"Set up the filter configuration","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"filter_config = OfflineFilterConfig(original_data_filename=\"SW_IO_with_tracer.jld2\", # Where the original simulation output is\n                                    output_filename = \"SW_IO_with_tracer_filtered.jld2\", # Where to save the filtered output\n                                    var_names_to_filter = (\"T\",), # Which variables to filter\n                                    velocity_names = (\"u\",\"v\"), # Velocities to use for remapping\n                                    architecture = CPU(), # CPU() or GPU(), if GPU() make sure you have CUDA.jl installed and imported\n                                    Î”t = 1e-2, # Time step of filtering simulation\n                                    T_out=0.1, # How often to output filtered data\n                                    N=2, # Order of Butterworth filter\n                                    freq_c = 0.5, #Â Cut-off frequency of Butterworth filter\n                                    compute_mean_velocities= true, # Whether to compute mean velocities\n                                    output_netcdf = true, # Whether to output filtered data to a netcdf file in addition to .jld2\n                                    delete_intermediate_files = true, # Delete the individual output of the forward and backward passes\n                                    compute_Eulerian_filter = true) # Whether to compute the Eulerian filter for comparison","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"OfflineFilterConfig(\"SW_IO_with_tracer.jld2\", (\"T\",), (\"u\", \"v\"), 0.0, 20.0, 20.0, CPU(), 0.1, (a1 = 0.17677669529663687, b1 = 0.1767766952966369, c1 = 0.35355339059327373, d1 = 0.3535533905932738, N_coeffs = 1), 0.01, InMemory{Int64}(1, 4), true, \"forward_output.jld2\", \"backward_output.jld2\", \"SW_IO_with_tracer_filtered.jld2\", 5, true, true, true, true, true, WENO{3, Float64, Float32}(order=5)\nâ”œâ”€â”€ buffer_scheme: WENO{2, Float64, Float32}(order=3)\nâ””â”€â”€ advection_velocity_scheme: Centered(order=4), 50Ã—50Ã—1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3Ã—3Ã—0 halo\nâ”œâ”€â”€ Periodic x âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”x=0.125664\nâ”œâ”€â”€ Periodic y âˆˆ [4.03717e-17, 6.28319) regularly spaced with Î”y=0.125664\nâ””â”€â”€ Flat z                              , \"offline\")","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Run-the-offline-Lagrangian-filter","page":"Shallow water inertial oscillation offline","title":"Run the offline Lagrangian filter","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"run_offline_Lagrangian_filter(filter_config)","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"[ Info: Loaded data from SW_IO_with_tracer.jld2\n[ Info: Created original variables: (:T,)\n[ Info: Created filtered variables: (:T_C1, :xi_u_C1, :xi_v_C1, :T_S1, :xi_u_S1, :xi_v_S1)\n[ Info: Created forcing for filtered variables\n[ Info: Created model\n[ Info: Initialised filtered variables\n[ Info: Defined outputs\n[ Info: Defined simulation\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (20.978 seconds)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (12.526 seconds).\n[ Info: Simulation time: 2 seconds\n[ Info: Simulation time: 4 seconds\n[ Info: Simulation time: 6 seconds\n[ Info: Simulation time: 8 seconds\n[ Info: Simulation time: 10 seconds\n[ Info: Simulation time: 12 seconds\n[ Info: Simulation time: 14 seconds\n[ Info: Simulation time: 16 seconds\n[ Info: Simulation time: 18 seconds\n[ Info: Simulation is stopping after running for 6.517 minutes.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n[ Info: Simulation time: 20 seconds\n[ Info: Initializing simulation...\n[ Info: Simulation time: 0 seconds\n[ Info:     ... simulation initialization complete (63.269 ms)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (200.437 ms).\n[ Info: Simulation time: 2 seconds\n[ Info: Simulation time: 4 seconds\n[ Info: Simulation time: 6 seconds\n[ Info: Simulation time: 8 seconds\n[ Info: Simulation time: 10 seconds\n[ Info: Simulation time: 12 seconds\n[ Info: Simulation time: 14 seconds\n[ Info: Simulation time: 16 seconds\n[ Info: Simulation time: 18 seconds\n[ Info: Simulation is stopping after running for 5.444 minutes.\n[ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds.\n[ Info: Simulation time: 20 seconds\n[ Info: Combined forward and backward contributions into SW_IO_with_tracer_filtered.jld2\n[ Info: Wrote regridded data to new variables with _at_mean suffix in file SW_IO_with_tracer_filtered.jld2\n[ Info: Computing Eulerian filter for variable T\n[ Info: Computing Eulerian filter for variable u\n[ Info: Computing Eulerian filter for variable v\n[ Info: Wrote NetCDF file to SW_IO_with_tracer_filtered.nc\n","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/#Visualisation","page":"Shallow water inertial oscillation offline","title":"Visualisation","text":"","category":"section"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"using CairoMakie","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"Now we animate the results.","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"timeseries1 = FieldTimeSeries(filter_config.output_filename, \"T\")\ntimeseries2 = FieldTimeSeries(filter_config.output_filename, \"T_Eulerian_filtered\")\ntimeseries3 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered\")\ntimeseries4 = FieldTimeSeries(filter_config.output_filename, \"T_Lagrangian_filtered_at_mean\")\n\ntimes = timeseries1.times\n\nset_theme!(Theme(fontsize = 20))\nfig = Figure(size = (1300, 500))\n\naxis_kwargs = (xlabel = \"x\",\n               ylabel = \"y\",\n               limits = ((0, 2*pi), (0, 2*pi)),\n               aspect = AxisAspect(1))\n\nax1 = Axis(fig[2, 1]; title = \"Raw\", axis_kwargs...)\nax2 = Axis(fig[2, 2]; title = \"Eulerian filtered\", axis_kwargs...)\nax3 = Axis(fig[2, 3]; title = \"Lagrangian filtered\", axis_kwargs...)\nax4 = Axis(fig[2, 4]; title = \"Lagrangian filtered at mean\", axis_kwargs...)\n\n\nn = Observable(1)\nObservable(1)\n\nvar1 = @lift timeseries1[$n]\nvar2 = @lift timeseries2[$n]\nvar3 = @lift timeseries3[$n]\nvar4 = @lift timeseries4[$n]\n\nheatmap!(ax1, var1; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax2, var2; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax3, var3; colormap = :Spectral, colorrange = (0, 1))\nheatmap!(ax4, var4; colormap = :Spectral, colorrange = (0, 1))\n\n\ntitle = @lift \"Tracer T at time = \" * string(round(times[$n], digits=2))\nLabel(fig[1, 1:4], title, fontsize=24, tellwidth=false)\n\nfig\n\nframes = 1:length(times)\n\n@info \"Making an animation\"\n\nCairoMakie.record(fig, \"IO_filtered_tracer_movie_offline.mp4\", frames, framerate=24) do i\n    n[] = i\nend","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"\"IO_filtered_tracer_movie_offline.mp4\"","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"(Image: )","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"We see that the Eulerian filter smudges the tracer field as it is advected by the inertial oscillations. The Lagrangian means directly calculated by this method are identical to the raw fields for the tracer and buoyancy shown, as they are conservative fields. However, when we remap to a mean reference position, we see the value of the Lagrangian filter in effectively removing the oscillations while preserving the tracer structures.","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"#Â We remove these files to keep things tidy, keep them for analysis if desired\nrm(filename_stem * \".jld2\")\nrm(filter_config.output_filename)\nrm(filter_config.output_filename[1:end-5] * \".nc\")","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"","category":"page"},{"location":"literated/offline_filter_shallow_water_IO/","page":"Shallow water inertial oscillation offline","title":"Shallow water inertial oscillation offline","text":"This page was generated using Literate.jl.","category":"page"},{"location":"offline_filtering/offline_how_it_works/#How-it-works","page":"How it works","title":"How it works","text":"","category":"section"},{"location":"offline_filtering/offline_how_it_works/","page":"How it works","title":"How it works","text":"To be added (see run_offline_lagrangian_filter.jl)","category":"page"},{"location":"#OceananigansLagrangianFilter.jl","page":"Home","title":"OceananigansLagrangianFilter.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package to compute Lagrangian temporal filters of Oceananigans.jl simulation output","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package builds on and is intended to be used with Oceananigans.jl (Wagner et al., 2025).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Lagrangian filter can be run in two ways","category":"page"},{"location":"","page":"Home","title":"Home","text":"Online: integrated into your Oceananigans simulation. This avoids the need to save data at wave-resolving resolution, but the available filter shapes are not as desirable. \nOffline: run after your Oceananigans simulation (or, feasibly, on any simulation output worked into the same format as Oceananigans native output) on saved data. Data should be at a temporal resolution that resolves the high frequency motions to be filtered. Velocities and the fields to be filtered need to be provided. The post-processing filter step runs similarly to an Oceananigans simulation, using the Oceananigans infrastructure to solve the filtering PDEs. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"}]
}
